<?xml version="1.0"?>
<Definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <ShipBlueprints>
    <ShipBlueprint xsi:type="MyObjectBuilder_ShipBlueprintDefinition">
      <Id Type="MyObjectBuilder_ShipBlueprintDefinition" Subtype="Hoverscript Testbed" />
      <DisplayName>Mr. Gherkin</DisplayName>
      <CubeGrids>
        <CubeGrid>
          <SubtypeName />
          <EntityId>140680239175662835</EntityId>
          <PersistentFlags>CastShadows InScene</PersistentFlags>
          <PositionAndOrientation>
            <Position x="57734.416988206154" y="8890.3261203703532" z="11954.918315760293" />
            <Forward x="-0.0427716076" y="0.942379236" z="-0.3318011" />
            <Up x="0.972117662" y="0.115895212" z="0.20385173" />
            <Orientation>
              <X>0.442397863</X>
              <Y>0.371999443</Y>
              <Z>-0.496323</Z>
              <W>0.6477376</W>
            </Orientation>
          </PositionAndOrientation>
          <LocalPositionAndOrientation xsi:nil="true" />
          <GridSizeEnum>Small</GridSizeEnum>
          <CubeBlocks>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_BatteryBlock">
              <SubtypeName>SmallBlockBatteryBlock</SubtypeName>
              <EntityId>117670067693090212</EntityId>
              <Min x="2" y="3" z="0" />
              <BlockOrientation Forward="Up" Up="Right" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <Owner>144115188075855883</Owner>
              <BuiltBy>144115188075855883</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>2</NumberInGrid>
              <Enabled>true</Enabled>
              <CurrentStoredPower>1</CurrentStoredPower>
              <ProducerEnabled>true</ProducerEnabled>
              <MaxStoredPower>0</MaxStoredPower>
              <SemiautoEnabled>false</SemiautoEnabled>
              <OnlyDischargeEnabled>false</OnlyDischargeEnabled>
              <ChargeMode>0</ChargeMode>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="2" z="0" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="2" z="-1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="2" z="-2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="2" z="-3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="2" z="-3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="2" z="-2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="2" z="-3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="2" z="1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="2" z="2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="2" z="3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="2" z="-1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="2" z="0" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="2" z="1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="2" z="2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="2" z="3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="2" z="3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="2" z="2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="2" z="1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="2" z="0" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="2" z="-1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="2" z="-2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="2" z="-2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="2" z="-1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="2" z="0" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="2" z="1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="2" z="2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="2" z="3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="3" y="2" z="3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="3" y="2" z="2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="3" y="2" z="1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="3" y="2" z="0" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="3" y="2" z="-1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="3" y="2" z="-2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="3" y="2" z="-3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="2" z="-3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="2" z="-3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="2" z="-2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="2" z="-1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="2" z="0" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="2" z="1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="2" z="2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="2" z="3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-3" y="2" z="3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-3" y="2" z="2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-3" y="2" z="1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-3" y="2" z="0" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-3" y="2" z="-1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-3" y="2" z="-2" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-3" y="2" z="-3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="3" y="2" z="4" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="2" z="4" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="2" z="4" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="2" z="4" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="2" z="4" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="2" z="4" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-3" y="2" z="4" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-3" y="2" z="5" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-2" y="2" z="5" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="-1" y="2" z="5" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="0" y="2" z="5" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="1" y="2" z="5" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="2" y="2" z="5" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>SmallBlockArmorBlock</SubtypeName>
              <Min x="3" y="2" z="5" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_BatteryBlock">
              <SubtypeName>SmallBlockBatteryBlock</SubtypeName>
              <EntityId>98414421869225770</EntityId>
              <Min x="-1" y="3" z="0" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <Owner>144115188075855883</Owner>
              <BuiltBy>144115188075855883</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>1</NumberInGrid>
              <Enabled>true</Enabled>
              <CurrentStoredPower>1</CurrentStoredPower>
              <ProducerEnabled>true</ProducerEnabled>
              <MaxStoredPower>0</MaxStoredPower>
              <SemiautoEnabled>false</SemiautoEnabled>
              <OnlyDischargeEnabled>false</OnlyDischargeEnabled>
              <ChargeMode>0</ChargeMode>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>107687324066321535</EntityId>
              <Min x="-4" y="1" z="0" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>12</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_RemoteControl">
              <SubtypeName>SmallBlockRemoteControl</SubtypeName>
              <EntityId>110691850627556070</EntityId>
              <Min x="0" y="3" z="-1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <Owner>144115188075855883</Owner>
              <BuiltBy>144115188075855883</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyAutopilotComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_AutopilotComponent">
                      <AutoPilotEnabled>false</AutoPilotEnabled>
                      <FlightMode>0</FlightMode>
                      <CurrentWaypointIndex>-1</CurrentWaypointIndex>
                      <Waypoints />
                      <DockingModeEnabled>false</DockingModeEnabled>
                      <CollisionAvoidance>false</CollisionAvoidance>
                      <Direction>0</Direction>
                      <AutopilotSpeedLimit>100</AutopilotSpeedLimit>
                      <WaitForFreeWay>false</WaitForFreeWay>
                      <WaypointThresholdDistance>0</WaypointThresholdDistance>
                      <Coords />
                      <Names />
                      <LookAtPosition xsi:nil="true" />
                      <FacingDirection>Forward</FacingDirection>
                      <AlignToGravity>true</AlignToGravity>
                      <MinHeightAboveTerrain>25</MinHeightAboveTerrain>
                      <IsWorkAreaReturningToStart>false</IsWorkAreaReturningToStart>
                      <WorkAreaStartForward>
                        <X>0</X>
                        <Y>0</Y>
                        <Z>0</Z>
                      </WorkAreaStartForward>
                      <PitchAngle>0</PitchAngle>
                      <RollAngle>0</RollAngle>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>Controller</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>2</NumberInGrid>
              <UseSingleWeaponMode>false</UseSingleWeaponMode>
              <Toolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots />
                <SlotsGamepad />
              </Toolbar>
              <SelectedGunId xsi:nil="true" />
              <BuildToolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots />
                <SlotsGamepad />
              </BuildToolbar>
              <OnLockedToolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots />
                <SlotsGamepad />
              </OnLockedToolbar>
              <IsTargetLockingEnabled>false</IsTargetLockingEnabled>
              <PreviousControlledEntityId xsi:nil="true" />
              <AutoPilotEnabled>false</AutoPilotEnabled>
              <FlightMode>0</FlightMode>
              <BindedCamera>0</BindedCamera>
              <CurrentWaypointIndex>-1</CurrentWaypointIndex>
              <Waypoints />
              <Direction>0</Direction>
              <DockingModeEnabled>false</DockingModeEnabled>
              <CollisionAvoidance>false</CollisionAvoidance>
              <Coords />
              <Names />
              <WaypointThresholdDistance>0</WaypointThresholdDistance>
              <IsMainRemoteControl>false</IsMainRemoteControl>
              <WaitForFreeWay>false</WaitForFreeWay>
              <IsUpdatedSave>true</IsUpdatedSave>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>116607995786718426</EntityId>
              <Min x="4" y="1" z="0" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>11</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>119974640262227310</EntityId>
              <Min x="-4" y="1" z="1" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>10</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>124967201032780574</EntityId>
              <Min x="4" y="1" z="1" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>9</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>88892069110835830</EntityId>
              <Min x="-4" y="1" z="2" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>8</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>100671069778952157</EntityId>
              <Min x="4" y="1" z="2" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>7</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>131668387474099061</EntityId>
              <Min x="-4" y="2" z="3" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>23</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>74501939042574328</EntityId>
              <Min x="4" y="2" z="3" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>24</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Gyro">
              <SubtypeName>SmallBlockGyro</SubtypeName>
              <EntityId>81615184480683952</EntityId>
              <Min x="-1" y="5" z="1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <Owner>144115188075855883</Owner>
              <BuiltBy>144115188075855883</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>3</NumberInGrid>
              <Enabled>true</Enabled>
              <GyroPower>0.6079323</GyroPower>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Gyro">
              <SubtypeName>SmallBlockGyro</SubtypeName>
              <EntityId>108844942626453866</EntityId>
              <Min x="1" y="5" z="1" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <Owner>144115188075855883</Owner>
              <BuiltBy>144115188075855883</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>4</NumberInGrid>
              <Enabled>true</Enabled>
              <GyroPower>0.6079323</GyroPower>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>97764649254316501</EntityId>
              <Min x="1" y="2" z="-4" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>25</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>129143245592725911</EntityId>
              <Min x="-3" y="2" z="-4" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>26</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>118630050525901878</EntityId>
              <Min x="-4" y="2" z="-3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>21</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>126882468144671402</EntityId>
              <Min x="4" y="2" z="-3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>22</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Gyro">
              <SubtypeName>SmallBlockGyro</SubtypeName>
              <EntityId>104376957551328860</EntityId>
              <Min x="0" y="5" z="2" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <Owner>144115188075855883</Owner>
              <BuiltBy>144115188075855883</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>1</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_TextPanel">
              <SubtypeName>SmallLCDPanel</SubtypeName>
              <EntityId>110375860054823020</EntityId>
              <Min x="-1" y="3" z="3" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <Owner>144115188075855883</Owner>
              <BuiltBy>144115188075855883</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>1</NumberInGrid>
              <Enabled>true</Enabled>
              <Description />
              <Title>Title</Title>
              <AccessFlag>READ_AND_WRITE_FACTION</AccessFlag>
              <ChangeInterval>0</ChangeInterval>
              <SelectedImages>
                <string>Offline</string>
              </SelectedImages>
              <Font Type="MyObjectBuilder_FontDefinition" Subtype="Debug" />
              <FontSize>1</FontSize>
              <PublicDescription />
              <PublicTitle>Public title</PublicTitle>
              <ShowText>NONE</ShowText>
              <FontColor>
                <PackedValue>4294967295</PackedValue>
                <X>255</X>
                <Y>255</Y>
                <Z>255</Z>
                <R>255</R>
                <G>255</G>
                <B>255</B>
                <A>255</A>
              </FontColor>
              <BackgroundColor>
                <PackedValue>4278190080</PackedValue>
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R>0</R>
                <G>0</G>
                <B>0</B>
                <A>255</A>
              </BackgroundColor>
              <CurrentShownTexture>0</CurrentShownTexture>
              <ContentType>TEXT_AND_IMAGE</ContentType>
              <SelectedScript />
              <TextPadding>2</TextPadding>
              <Version>1</Version>
              <ScriptBackgroundColor>
                <PackedValue>4288108544</PackedValue>
                <X>0</X>
                <Y>88</Y>
                <Z>151</Z>
                <R>0</R>
                <G>88</G>
                <B>151</B>
                <A>255</A>
              </ScriptBackgroundColor>
              <ScriptForegroundColor>
                <PackedValue>4294962611</PackedValue>
                <X>179</X>
                <Y>237</Y>
                <Z>255</Z>
                <R>179</R>
                <G>237</G>
                <B>255</B>
                <A>255</A>
              </ScriptForegroundColor>
              <Sprites>
                <Length>0</Length>
              </Sprites>
              <SelectedRotationIndex>0</SelectedRotationIndex>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_MyProgrammableBlock">
              <SubtypeName>SmallProgrammableBlock</SubtypeName>
              <EntityId>76699081222040111</EntityId>
              <Min x="0" y="5" z="0" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <Owner>144115188075855883</Owner>
              <BuiltBy>144115188075855883</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyModStorageComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_ModStorageComponent">
                      <Storage>
                        <dictionary>
                          <item>
                            <Key>74de02b3-27f9-4960-b1c4-27351f2b06d1</Key>
                            <Value>// if edited manually, reload with command 'load'
stop
updatefrequency=30
gyrolimitrpm=60
thrustaccellimit=50
thrustvellimit=100
pitchoffsetdegrees=0
tiltmaxdegrees=60
pitchangleclipdegrees=0.05
rollangleclipdegrees=0.03
pitchangleslopdegrees=0.1
rollangleslopdegrees=0.1
steeringsensitivity=1
pitchsensitivity=0.2
gyrostoppability=2E-05
alignangularresponsep2=1
alignangularresponsep=10
alignangularresponsei=0.1
alignangularresponsed=0
alignangularresponsed2=0.1
tiltpower=0.25
maxdownwardvelocity=25
alignlinearresponsep2=2
alignlinearresponsep=4
alignlinearresponsei=0
alignlinearresponsed2=1
alignlinearresponsed=20
thrustvelslop=0.5
thrustposslop=0.25
unlock
targetaltitude=7.87361933712036</Value>
                          </item>
                        </dictionary>
                      </Storage>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <CustomName>A Programmable Block</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>1</NumberInGrid>
              <Enabled>true</Enabled>
              <TextPanelsNew>
                <MySerializedTextPanelData>
                  <ChangeInterval>0</ChangeInterval>
                  <Font Type="MyObjectBuilder_FontDefinition" Subtype="Debug" />
                  <FontSize>1</FontSize>
                  <ShowText>NONE</ShowText>
                  <FontColor>
                    <PackedValue>4294967295</PackedValue>
                    <X>255</X>
                    <Y>255</Y>
                    <Z>255</Z>
                    <R>255</R>
                    <G>255</G>
                    <B>255</B>
                    <A>255</A>
                  </FontColor>
                  <BackgroundColor>
                    <PackedValue>4278190080</PackedValue>
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R>0</R>
                    <G>0</G>
                    <B>0</B>
                    <A>255</A>
                  </BackgroundColor>
                  <CurrentShownTexture>0</CurrentShownTexture>
                  <SelectedScript />
                  <TextPadding>2</TextPadding>
                  <ScriptBackgroundColor>
                    <PackedValue>4288108544</PackedValue>
                    <X>0</X>
                    <Y>88</Y>
                    <Z>151</Z>
                    <R>0</R>
                    <G>88</G>
                    <B>151</B>
                    <A>255</A>
                  </ScriptBackgroundColor>
                  <ScriptForegroundColor>
                    <PackedValue>4294962611</PackedValue>
                    <X>179</X>
                    <Y>237</Y>
                    <Z>255</Z>
                    <R>179</R>
                    <G>237</G>
                    <B>255</B>
                    <A>255</A>
                  </ScriptForegroundColor>
                  <Sprites>
                    <Length>0</Length>
                  </Sprites>
                </MySerializedTextPanelData>
                <MySerializedTextPanelData>
                  <ChangeInterval>0</ChangeInterval>
                  <Font Type="MyObjectBuilder_FontDefinition" Subtype="Debug" />
                  <FontSize>1</FontSize>
                  <ShowText>NONE</ShowText>
                  <FontColor>
                    <PackedValue>4294967295</PackedValue>
                    <X>255</X>
                    <Y>255</Y>
                    <Z>255</Z>
                    <R>255</R>
                    <G>255</G>
                    <B>255</B>
                    <A>255</A>
                  </FontColor>
                  <BackgroundColor>
                    <PackedValue>4278190080</PackedValue>
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R>0</R>
                    <G>0</G>
                    <B>0</B>
                    <A>255</A>
                  </BackgroundColor>
                  <CurrentShownTexture>0</CurrentShownTexture>
                  <SelectedScript />
                  <TextPadding>2</TextPadding>
                  <ScriptBackgroundColor>
                    <PackedValue>4288108544</PackedValue>
                    <X>0</X>
                    <Y>88</Y>
                    <Z>151</Z>
                    <R>0</R>
                    <G>88</G>
                    <B>151</B>
                    <A>255</A>
                  </ScriptBackgroundColor>
                  <ScriptForegroundColor>
                    <PackedValue>4294962611</PackedValue>
                    <X>179</X>
                    <Y>237</Y>
                    <Z>255</Z>
                    <R>179</R>
                    <G>237</G>
                    <B>255</B>
                    <A>255</A>
                  </ScriptForegroundColor>
                  <Sprites>
                    <Length>0</Length>
                  </Sprites>
                </MySerializedTextPanelData>
              </TextPanelsNew>
              <Program>// HOVER ALIGNER
// http://steamcommunity.com/sharedfiles/filedetails/?id=583272553
// for Space Engineers in-game scripting for Programmable block
// public domain code by Sean L. Palmer

// Planetary vehicle guidance assistance system.
// A combined gyro gravity orientation and thruster altitude aligner.
// Orients a ship so that its specified remote control's Down axis is aligned with local gravity force.
// to within a specified angle tolerance
// In other words, keeps hovercraft from flipping over, aligned with the ground.
// The main ship inertial dampers handle keeping it afloat!
// Some folks use it for satellites, some use it as mecha balance assistance.
// Can even detect slope of ground and maintain distance from terrain.

// BLOCKS NEEDED:
//   a programmable block, with this script
//   a remote control or cockpit facing the proper way (down direction is most important)
//   some thrusters, mostly pointing down
//   some gyros, any orientation
//   a text panel (optional) for diagnostics
// Ownership of all the blocks should be the same, to ensure they can intercommunicate.
// Make a group named same as GroupName, containing all those blocks.
// Now Run the script with Argument "go" somehow; 
// If you want to stop the aligner, Run with Argument "stop" to gracefully shut off all the gyro/thruster overrides
// I like to set up the ship cockpit toolbar with actions to stop, go, unlock, lockh/lock the aligner

const string GroupName = "Aligner"; // name of group in terminal containing cockpit, gyros, text panel
const string ScriptTitle = "Hover Aligner\nby p3st|cIdE\n";

// SCANNER

public static class Scanner
{
  #region fill from ctor // TODO readonly
  public static IMyProgrammableBlock Me;
  public static IMyGridTerminalSystem Terminal;
  public static string GroupName;
  public static TimeSpan RescanPeriod = Time.s(5); // damage, building can affect available blocks
  #endregion
  public static IMyBlockGroup Group;
  public static List&lt;IMyTerminalBlock&gt; Blocks = new List&lt;IMyTerminalBlock&gt;();
  public static bool FromCtor { get { return first; } }
  // may call before or after Module.Init()
  public static Module Init(IMyProgrammableBlock Me, IMyGridTerminalSystem Terminal, string GroupName)
  {
    Scanner.Me = Me;
    Scanner.Terminal = Terminal;
    Scanner.GroupName = GroupName;
    var m = new Module(); m.Name = "Scanner"; m.Tick = Update; return m;
  }
  // do not call until after calling Module.Init(modules) and also Init() above
  public static void Update()
  {
    bool success = true;
    if (DateTime.Now &gt;= RescanTime) try
      {
        success = Rescan();
      }
      catch (Exception e) { throw new Exception("Scan(" + first + "):\n" + e.Message); }
    if (first) { Module.Load(); Log.Echo(Log.scan.ToString()); first = false; }
    return;
  }

  public static void GetBlocksOfType&lt;T&gt;(List&lt;T&gt; list) where T : class
  {
    foreach (var t in Blocks) { var tt = t as T; if (tt != null) list.Add(tt); }
  }

  public static float Volume(IMyCubeBlock block) // in L
  {
    int nb = (block.Max - block.Min + 1).Volume(); //Dot(ref Vector3I.One); // total blocks in bounding box
    float e = block.CubeGrid.GridSize * .1f; // edge length in dm
    e *= e * e; // cubed for size in L of 1 cube
    return e * nb;
  }

  static bool Rescan()
  {
    bool success = true;
    Log.scan.Clear();
    Log.diagnostic.Clear();
    RescanTime = DateTime.Now + RescanPeriod;
    Group = null; // force re-find from name to deal with problems undocking from stations
    FindBlocks();
    if (first)
      try
      {
        bool ok = Check(); // NOT fatal
      }
      catch (Exception e) { throw new Exception("Scan.Check:\n" + e.Message); }
    foreach (var m in Module.All)
      try
      {
        if (!m.Scan())
        {
          Log.scan.AppendLine(m.Name + " scan fail!");
          success = false;
        } // persist to show all failures in log
      }
      catch (Exception e) { throw new Exception("Scan:" + m.Name + '\n' + e.Message); }
    if (!success) Log.scan.AppendLine("Blocks missing!\nCheck ownership consistency!");
    Log.Echo(Log.scan.ToString());
    Log.Echo(Log.diagnostic.ToString());
    return success;
  }

  static void FindBlocks()
  {
    if (Group == null &amp;&amp; GroupName != null)
    {
      Group = Terminal.GetBlockGroupWithName(GroupName);
      if (Group == null)
        Log.scan.AppendLine("No group called '" + GroupName + "' found!");
    }
    Blocks.Clear();
    if (Group != null) Group.GetBlocks(Blocks);
    else Terminal.GetBlocks(Blocks);
  }

  // we'd like to turn certain blocks on.
  static bool Check()
  {
    bool good = true;
    foreach (var b in Blocks)
    {
      if (b.CubeGrid.IsStatic)
        if (b is IMyThrust || b is IMyGyro || b is IMyShipController)
          Log.scan.AppendLine("'" + b.CustomName + "' is on station, can't use!"); // will also report !IsWorking
      if (!b.IsFunctional) // don't automatically re-enable blocks that may require manually disabled if things go kaput
        if (b is IMyTimerBlock || b is IMyTextPanel)
          (b as IMyFunctionalBlock).Enabled = true;
      // in ctor, ignore IsWorking status because the rest of the ship may not be initialized yet.
      if (!(b is IMyThrust) &amp;&amp; !b.IsWorking) // broken/off/unpowered blocks don't help
      { // but ALL blocks report !IsWorking during first ctor run...  Thrusts we toggle all the time, they can be off.
        Log.scan.AppendLine("'" + b.CustomName + "' is not working!"); //good = false; // not fatal.
      }
    }
    return good;
  }

  static DateTime RescanTime = DateTime.Now;
  static bool first = true; // called from Program ctor?
}

// MODULE
// Aids static classes coordination.
// Eases development in many ways.
// Other static classes don't derive from Module but provide one!
public class Module
{
  public string Name = "?";
  // Poor man's static class interface!
  // These delegates may not be null, but they all have sensible default implementations.
  public Func&lt;bool&gt; Scan = () =&gt; true; // skip scan and report success
  public Func&lt;string[], bool&gt; Parse = s =&gt; false; // parse one pre-tokenized command, unhandled
  public Action Tick = () =&gt; { }; // called once per frame; use Time module!
  public Func&lt;string[]&gt; Save = () =&gt; null; // save no state into array of commands
  // set before using rest of system
  public static IMyGridProgramRuntimeInfo run; // Time.dt != run.ElapsedTime
  // Structures script execution.
  public static readonly List&lt;Module&gt; All = new List&lt;Module&gt;();
  // Add all Modules during Program constructor.
  public static void Init(IEnumerable&lt;Module&gt; modules)
  {
    All.Clear(); All.AddRange(modules);
  }
  public static bool Commands(string commands, bool savechanges = false)
  {
    if (run == null) throw new Exception("Must set runtime");
    if (commands == null
     || (commands = commands.Trim()).Length == 0)
      return true;
    try
    {
      bool allhandled = true;
      bool somehandled = false;
      foreach (var cmd in commands.Split(Utility.LineSeps))
      {
        var c = cmd.Trim();
        if (c.Length == 0 // blank lines / in-between '\r' and '\n'
         || c.StartsWith("//")) // comments
          continue; // skip
        Log.Echo("command '" + c + "':");
        if (c == "toggle") if (Time.running) c = "stop"; else c = "go";
        if (c == "save") Store();
        else if (c == "load") Load();
        else
        {
          string[] tok = c.Split(Utility.AssignSeps);
          if (tok.Length == 0 || tok[0].Length == 0) continue; // skip blank-ish lines
          tok[0] = tok[0].ToLowerInvariant(); // don't require of all modules
          bool handled = false;
          // allow multiple modules to handle the same command,
          // contributing functionality (e.g. "stop" overload)
          foreach (var m in All)
            try
            {
              if (m.Parse != null &amp;&amp; m.Parse(tok))
                handled = true;
            }
            catch (Exception e) { throw new Exception("Load:" + m.Name + '\n' + e.Message); }
          Log.Echo("'" + c + "': " + (handled ? "ok" : "error"));
          if (!handled) allhandled = false;
          else somehandled = true;
        }
      }
      if (somehandled &amp;&amp; savechanges) Store(); // write back to CustomData
      return allhandled;
    }
    catch (Exception e) { throw new Exception("Module.Load:\n" + e.Message); }
  }

  public static bool Load()
  {
    return Scanner.Me == null ? false : Commands(Scanner.Me.CustomData);
  }

  public static void Update()
  {
    if (run == null) throw new Exception("Must set runtime");
    Scanner.Update();
    if (!Time.Run()) return;
    foreach (var m in All)
        m.Tick();
  }

  public static string Store() // serialize to string, save to Me.CustomData
  {
    List&lt;string&gt; saved = new List&lt;string&gt;();
    string result = "// if edited manually, reload with command 'load'\n";
    try
    {
      foreach (var s in All)
      {
        var c = s.Save();
        if (c != null) saved.AddArray(c);
      }
      result += string.Join("\n", saved);
    }
    catch (Exception e) { throw new Exception("Module.Store:\n" + e.Message + "\nSaving failed!"); }
    if (Scanner.Me != null)
      Scanner.Me.CustomData = result;
    return result;
  }
}

// TIME
// update rate management
public static class Time
{
  public static Module Init()
  {
    Chart.Title["time"] = TimeChart;
    Chart.Title["update"] = UpdateChart;
    var m = new Module(); m.Name = "Time"; m.Parse = Parse; m.Save = Save; return m;
  }

  public static bool running { get { return _running; } }
  public static bool proceed { get { return _dt.Ticks != 0; } }
  public static TimeSpan dt { get { return _dt; } private set { _dt = value; } } // delta time since last *full* Run (where we weren't waiting for the update period)
  public static float dts { get { return (float)dt.TotalSeconds; } } // _dt.Ticks * 1e-7f; } } // _dts; } } //delta time in seconds
  public static int dtms { get { return (int)_dt.Ticks / 10000; } }
  public static int ams { get { return (int)DateTime.Now.Ticks / 10000; } } // animated, wraps about 4x/hour; for cosmetic spinners.
  public static long gms { get { return (DateTime.Now - timeStarted).Ticks / 10000; } } // reset each session, otherwise stable increasing.

  public static Chart TimeChart = new Chart();
  public static Chart UpdateChart = new Chart();

  static int nticks;

  public static bool Run() // updates dt, variable timestep, returns whether rest of Modules need ticked
  { 
    TimeChart.Param = UpdateChart.Param = 1.4f; // 3 lines
    UpdateChart.Text = "Elapsed: " + Module.run.TimeSinceLastRun.TotalMilliseconds.ToString("f2") + " ms";
    UpdateChart.Text += "\nExec: " + Module.run.LastRunTimeMs.ToString("f2") + " ms";
    if (!running) TimeChart.Text = "Stopped";
    var now = DateTime.Now;
    UpdateChart.Text += "\nTick: " + (now - lastRun).TotalMilliseconds.ToString("f2") + " ms"; // true update time
    UpdateChart.Text += "\nTicks: " + ++nticks;
    lastRun = now;
    _dt = now - oldTime; // measure delta
    if (!_running || _dt &lt; UpdatePeriod) _dt = new TimeSpan(); // report 0 elapsed time until full period passed
    else oldTime = now; // advance
    if (running)
    {
      TimeChart.Text = "Running";
      TimeChart.Text += "\nElapsed: " + dtms.ToString("f1") + " ms";
      TimeChart.Text += '\n';
      if (_dt.Ticks != 0) TimeChart.Text += "(" + Pretty._(1/dts) + " Hz)";
      TimeChart.Text += "\nUpdate: " + Pretty._(UpdateFrequency) + " Hz";
    }
    if (_dt.Ticks != 0) nticks = 0;
    return proceed;
  }

  const int DefaultUpdateFrequency = 30; //20; //
  const float freqBias = .9f; // round to not skip updates due to tiny imprecisions
  public static TimeSpan UpdatePeriod = s(1.0 / (DefaultUpdateFrequency + freqBias));
  public static double UpdateFrequency { get { return 1 / UpdatePeriod.TotalSeconds - freqBias; } }
  static TimeSpan StopFlushPeriod = s(.1);
  static readonly TimeSpan tick1 = TimeSpan.FromTicks(1);
  static DateTime oldTime = DateTime.Now - tick1;
  static DateTime stopUntil = DateTime.Now - tick1;
  static DateTime lastRun = DateTime.Now - tick1;
  static readonly DateTime timeStarted = DateTime.Now; // last Recompile or world reload
  static TimeSpan _dt;
  static bool _running = false;

  static string[] Save()
  {
    return new string[] {
      _running ? "go" : "stop",
      "updatefrequency=" + Pretty._(Math.Round(UpdateFrequency))
    };
  }

  static bool Parse(string[] tokens)
  {
    if (tokens.Length == 1)
    {
      string varn = tokens[0];
      if (varn == "go") Go();
      else if (varn == "stop") Stop();
      else return false;
    } else {
      double val;
      if (!double.TryParse(tokens[1], out val)) return false;
      string varn = tokens[0];
      if (varn == "updatefrequency" &amp;&amp; val &gt;= 1 &amp;&amp; val &lt;= 60.5)
      {
        UpdatePeriod = Frequency(MathHelper.Clamp(val, 1.0, 60.0) + freqBias);
      }
      else return false;
    }
    return true;
  }

  public static void Go() { // begin actively controlling the ship
    if (DateTime.Now &lt; stopUntil) return; // do not allow restarting during the StopFlushPeriod
    _running = true;
    oldTime = DateTime.Now - tick1;
    Module.run.UpdateFrequency = Sandbox.ModAPI.Ingame.UpdateFrequency.Update1; //Update10; //
  }
  public static void Stop() {
    Module.run.UpdateFrequency = Sandbox.ModAPI.Ingame.UpdateFrequency.None; //Update100; //
    stopUntil = DateTime.Now + StopFlushPeriod;
    _running = false;
  }

  // TimeSpan.FromMilliseconds and .FromSeconds both mysteriously round to ms due to internal Interval helper function bug
  public static TimeSpan ms(double n) =&gt; TimeSpan.FromTicks((long)(1e4 * n));
  public static TimeSpan  s(double n) =&gt; TimeSpan.FromTicks((long)(1e7 * n));
  public static TimeSpan Frequency(double hz) =&gt; TimeSpan.FromTicks((long)(1e7 / hz));
}

// PID CONTROLLER

// to use such a controller for higher dimensions,
// use a combination of 1D PIDs

public class PIDControllerFloat
{
  public float Kp = 1, Ki = .1f, Kd = .1f; // some people factor out Kp so Ki and Kd are proportions of it.
  public float Kd2; // nonstandard extension: using partially-squared derivative of error.  REALLY helps control overshoot.
  public float Kp2; // nonstandard extension: use partially-squared error.  Aid spin-up behavior by limiting how much it can be misaligned without being way too strong near the limit.
  public float integralReduction = .001f; // nonstandard extension: reduce built-up integral slightly over time
  private float prevErr;
  private float integral;
  private float target;

  public float Error { get { return prevErr; } }
  public float Integral { get { return integral; } set { integral = value; } } // client may wish to reset the integral occasionally

  public void SetTarget(float s) //, double resetDistance) 
  {
    var targetDelta = s - target;
    prevErr += targetDelta; // pretend like we were already at the old setpoint to avoid a momentary hiccup
    // since we fixed prevErr, integral won't get bashed any harder now; it may take some time to unwind though.
    //if (mag(targetDelta) &gt; resetDistance)
    //	integral = 0; // abandon integral tracking if too far away from old setpoint.  Small changes can keep the integral error.
    target = s; 
  }
  // t is delta time, likely in seconds
  // v is current value of thing we're controlling
  // target is current target value, set point
  public float Advance(float t, float v) // returns the new control value to set to
  {
    var error = target - v;
    integral *= (float)Math.Exp(-integralReduction * t); // reduces slightly over time
    integral += error * t; // accumulate error
    var err2 = error * Math.Abs(error); // sqrsgn
    var derivative = (error - prevErr) / t; // not stored
    var deriv2 = derivative * Math.Abs(derivative);
    prevErr = error; // maintain error state for next run
    return Kp2 * err2
       + Kp * error
       + Ki * integral
       + Kd * derivative
       + Kd2 * deriv2; // sum up
  }
  // https://en.wikipedia.org/wiki/Braking_distance
  public static float MaxVelocityForDistanceStoprate(float d, float r)
  {
    if (d &lt; 0) throw new ArgumentException("must be &gt;= 0", "d");
    if (r &lt;= 0) return 0;
    return (float)Math.Sqrt(2 * r * d);
  }
}

// UTILITY

public static class Utility
{
  public static float  Sqr(float  x) { return x*x; }
  public static double Sqr(double x) { return x*x; }
  public static float  ClampAbs(float  x, float  lim) { return MathHelper.Clamp(x, -lim, lim); }
  public static double ClampAbs(double x, double lim) { return MathHelper.Clamp(x, -lim, lim); }

  public static float Frac(double x) { x -= (int)x; if (x &lt; 0) x += 1f; return (float)x; }
  public static float Wiggle(float x) { return (2f - Math.Abs(x)) * x; }

  // simple LFOs, phase in double precision, output 0 to 1
  public static bool Square(double w) { w = Frac(w + .25); return w &gt;= .5f; }
  public static float Saw(double w) { return Frac(w); }
  public static float Tri(double w) { return Math.Abs(2f * Frac(w + .5) - 1f); }
  public static float Wave(double w) { return Wiggle(Frac(w + .25) * 4 - 2) * .5f + .5f; }
  public static float Pulse(double w) { return 1f - Math.Abs(Wave(w) * 2f - 1f); }

  // clips out a region around zero, and closes up the gap linearly
  public static double DeadZone(double x, double clip)
  {
    return x &lt; -clip ? x + clip : x &gt; clip ? x - clip : 0.0;
  }

  // ensures that output values are not any smaller than pad, by sliding entire range away from zero by that amount; could just clamp them outward instead
  public static double BoostZone(double x, double pad)
  {
    return x &lt; -double.Epsilon ? x - pad : x &gt; double.Epsilon ? x + pad : 0.0;
  }
  // Attempt to cope with behavior of PID integral resetting when any override slider changes
  // by avoiding changing setting unless it would result in large enough actual difference to matter.
  public static bool SetWithMinDelta(ITerminalProperty&lt;float&gt; p, IMyTerminalBlock b, float v, float tiny = .01f, float mindeltafraction = .07f)
  {
    v = MathHelper.Clamp(v, p.GetMinimum(b), p.GetMaximum(b));
    if (Math.Abs(v) &lt; tiny) v = 0; // flush tiny #s to zero
    var old = p.GetValue(b);
    float mindelta = Math.Abs(old) * mindeltafraction + .002f;
    if ((v == 0 &amp;&amp; old == 0) || Math.Abs(old - v) &lt; mindelta) return false; // close enough already! do not fiddle with it, let gyro spin up
    p.SetValue(b, v); return true;
  }
  public static readonly char[] LineSeps = new char[] { '\n','\r','|',';' };
  public static readonly char[] AssignSeps = new char[] { '=', ':' };
}

// PRETTY
// prevent visual information overload, ease parsing
public static class Pretty
{
  static readonly float[] tcache = new float[] { 0f, .1f, .01f, .001f, .0001f };
  public static float NoTiny(float x, int dig = 1)
  {
    return Math.Abs(x) &lt; (dig &lt; tcache.Length ? tcache[dig] : (float)Math.Pow(.1, dig)) ? x*float.Epsilon : (float)Math.Round(x, dig);
  }
  public static string _(float  f) { return NoTiny(f, 1).ToString("g3"); }
  public static string _(double d) { return NoTiny((float)d, 1).ToString("g4"); }

  const string degUnit = " "; // angular degrees 
  public static string Degrees(double a) { return _((float)a) + degUnit; }
  public static string Radians(double a) { return Degrees(MathHelper.ToDegrees((float)a)); }
  public static string Degrees(Vector3 a) { return _(a) + degUnit; }
  public static string Radians(Vector3 a) { return Degrees(a * MathHelper.ToDegrees(1)); }
  public static string MultiLine(string name, Vector3 v, string unit)
  {
    return   name + "x: " + Pretty._(v.X)
      + '\n' + name + "y: " + Pretty._(v.Y) + ' ' + unit 
      + '\n' + name + "z: " + Pretty._(v.Z);
  }

  static string oAxSep = " ";
  static readonly char[] iAxSep = new[] { ' ', '\t', ',' };
  public static string _(Vector3 v)
  {
    return _(v.X) + oAxSep + _(v.Y) + oAxSep + _(v.Z);
  }
  public static string _(Vector3D v)
  {
    return _(v.X) + oAxSep + _(v.Y) + oAxSep + _(v.Z);
  }
  public static string _(Quaternion q)
  {
    return _(q.X) + oAxSep + _(q.Y) + oAxSep + _(q.Z) + oAxSep + _(q.W); //q.ToString(); //
  }
}

// GRAPH
// Low level graphing support
// deals with the peculiarities of drawing using Space Engineers text panels
public static class Graph
{
  public static Module Init()
  {
    var m = new Module();
    m.Name = "Graph";
    m.Tick = Update;
    return m;
  }

  public const float row2fontsize = 2.1f; // 2 rows
  public static readonly int smChartWidth = Screen.FontColumns(row2fontsize, 8);

  public static Color Twirl;

  static void Update()
  {
    var t = 1f / 3000 * Time.ams;
    Twirl = Hue(t);
    Twirl = Desat(Twirl, .9f - .4f * Utility.Sqr(Utility.Pulse(t/17)));
    Twirl = Glo(Twirl, .5f + .5f * (float)Math.Pow(Utility.Pulse(t/23) * .2f, 32));
  }

  public static Color StatusColor(double status)
  {
    status = MathHelper.Saturate(status);
    var t = 1f / 500 * Time.ams; // 2/s
    var stat = Hue((1f - status) * .33f); // from green at 0 to red at 1 and beyond // .5f cyan could work
    stat = Glo(stat, Utility.Pulse(t) * (float)status * .3f); // blink stronger with more error
    return stat;
  }

  public static Color Hue(double H) // 0/6:R, 1/6:Y, 2/6:G, 3/6:C, 4/6:B, 5/6:M
  {
    var h6 = 6f * Utility.Frac(H); // range reduce angle
    int i = (int)h6; float f = h6 - i;
    float e; Vector3 c; // feeling clever
    if ((i&amp;1) != 0) { e = 1 - f; f = 1; } else { e = 1; }
         if (i &lt; 2) c = new Vector3(e, f, 0);
    else if (i &lt; 4) c = new Vector3(0, e, f);
    else            c = new Vector3(f, 0, e);
    return (Color)c;
  }

  public static Color Glo(Color c, float a) { return Color.Lerp(c, Color.White, a); }
  public static Color Dim(Color c, float a) { return Color.Lerp(Color.Black, c, a); }
  public static Color Desat(Color c, float a) { return Color.Lerp(c, new Color(Luma(c)), a); }

  public static float Lumi(Vector3 clinear) { return Vector3.Dot(new Vector3(.2126f, .7152f, .0722f), clinear); } // lumi Y from linear RGB using ITU-R Rec. BT.709 / sRGB
  public static float Luma(Vector3 cgamma ) { return Vector3.Dot(new Vector3(.2990f, .5870f, .1140f), cgamma ); } // luma Y' from gamma RGB using ITU-R Rec. BT.601-2 luma

  public static string Fraction(double f, int w) // a simple 1-line horizontal bar graph representing a percentage
  {
    var cfill = (int)(MathHelper.Saturate(f)*w);
    return new string('I', cfill);// + new string(' ', w - cfill); // left is FG (filled) and right is BG (empty)
  }

  static int Pos(double v, int width, int center, double maximum)
  {
      return MathHelper.Clamp((int)Math.Round(center*v/maximum) + center, 0, width-1);
  }

  public static string Limit(double v, double limit, double maxi, int w)
  {
    if ((w &amp; 1) == 0) --w; // width should be odd
    if (Math.Abs(v) &gt; maxi) return new string(v &lt; 0 ? '' : '', w); 
    int c = w &gt;&gt; 1; // center
    int lo = Pos(-limit, w, c, maxi);
    var g = new string('', lo);
    g = g + new string(' ', w - lo*2) + g;
    int pat = Pos(v, w, c, maxi);
    char nub = v &lt; -limit ? '' : v &gt; limit ? '' : 'I';
    return g.Substring(0, Math.Max(0, pat)) + nub + g.Substring(Math.Min(w, pat + 2));
  }
}

// VESSEL

// Tracks the state of a vessel.  A vessel is a collection of connected grids.
// Supports multiple controllers!  (cockpits, control stations, remote controls)
public static class Vessel
{   
  public static Module Init()
  {
    if (gravity.gravChart == null) gravity.gravChart = new Chart();
    Chart.Title["mass"] = massChart;
    Chart.Title["grav"] = gravity.gravChart;
    Chart.Title["pos"] = posChart;
    Chart.Title["vel"] = velChart;
    Chart.Title["ori"] = oriChart;
    Chart.Title["rot"] = rotChart;
    var m = new Module(); m.Name = "Vessel"; m.Scan = Rescan; m.Tick = Update; m.Parse = Parse; return m;
  }

  public static IMyShipController Controller = null; // presently active controller, being controlled by a player

  public struct Gravity
  {
    public const float StandardG = 9.80665f; // m/s
    public float Strength;  // present effective acceleration in m/s
    public Vector3D World;  // scaled by strength (up to 1G) world space at this vessel's location
    public Vector3  WorldDir; // unit length
    public Vector3D Local;  // scaled by strength (up to 1G) ship local space
    public Vector3  LocalDir; // unit length
    public Chart gravChart;

    public void Update(IMyShipController c, Quaternion worldToShip)
    {
      if (c == null) { World = WorldDir = Local = LocalDir = new Vector3(); Strength = 0; gravChart.Text = "Misconfigured!"; return; }
      World = c.GetNaturalGravity(); // gravity acceleration vector in m/s - ships without artificial mass ignore artificial gravity
      Strength = (float)World.Length();
      Local = Vector3.Transform(World, worldToShip);
      LocalDir = Vector3D.Normalize(Local / Strength);
      WorldDir = Vector3D.Normalize(World / Strength);
      if (Vector3D.IsZero(World, .01))
      { // normalized will be bogus, zero them.
        WorldDir = LocalDir = new Vector3();
        //Log.Output("No Gravity!");
        gravChart.Text = "No gravity";
      }
      else
      {
        //Log.Output("gravity: " + Pretty._(gravity.Local) + " m/s (local)");
        //Log.Output("gravity: " + Pretty._(gravity.Local*(1/StandardG)) + " G (local)");
        //Log.Output("gravity dir: " + Pretty._(gravity.LocalDir) + " (local)");
        gravChart.Text = "Gravity: " + Pretty._(Vessel.gravity.Strength) + " m/s"; //" G";
          }
      gravChart .UpdateColor(0); gravChart.Param = 2.6f; 
    }
  }
  public static Gravity gravity; // for the active controller, if any; not tracking multiple gravities or altitudes yet.

  public static bool Rescan()
  {
    Controllers.Clear();
    Scanner.GetBlocksOfType(Controllers);
    FindController();
    if (Controller == null)
      Log.scan.AppendLine("No controllers found!");
    UpdateMass();
    UpdateMatrix();
    return true;
  }

  // it's pretty crucial that this match the actual ship mass otherwise we may not be able to hover or will overthrust like mad
  public static double Mass; // total in kg

  // I'm torn whether to move these into Motion/Rotion or leave here since they're obtained from IMyShipController
  public static Vector3D Position;

  public static Vector3 LinearVelocity; // in meters/s in world space
  public static Vector3 LinearAcceleration; // in meters/s in world space

  // an angular velocity vector is a rotation axis scaled by speed in radians/second
  public static Vector3 AngularVelocity; // in radians/s per axis in world space

  public static Quaternion worldToShip; // inverse orientation
  public static Quaternion shipToWorld { get { return Quaternion.Conjugate(worldToShip); } } // from ship controller to world space

  public static Vector3 WorldToShipDir(Vector3 d) { return Vector3.Transform(d, worldToShip); }
  public static Vector3 ShipToWorldDir(Vector3 d) { return Vector3.Transform(d, shipToWorld); }

  static Chart massChart = new Chart();
  static Chart posChart = new Chart();
  static Chart velChart = new Chart();
  static Chart oriChart = new Chart();
  static Chart rotChart = new Chart();

  public static bool Parse(string[] tokens)
  {
    if (tokens.Length == 1)
    {
      string varn = tokens[0];
      return false;
    }
    else
    {
      double val;
      if (!double.TryParse(tokens[1], out val)) return false;
      string varn = tokens[0];
      if (varn == "extramass") {} //ExtraMass = val;
      else if (varn == "cargomult") {} //CargoMult = val;
      else return false;
    }
    return true;
  }

  static void FindController() // find the one under control if possible, or use the first controller available otherwise.
  {
    Controller = null;
    foreach (var c in Controllers)
      if (c.IsUnderControl
        || Controller == null
        || (!c.IsUnderControl &amp;&amp; c.GetValueBool("MainCockpit")) // prefer main over uncontrolled non-main
        ) // TODO prefer controller on same grid as PB.
        Controller = c;
    // unfortunately, in-game scripts do not have access to the IsMainCockpit property on IShipController nor the MainCockpit property of ICubeGrid
  }

  static void UpdateMass()
  {
    if (Controller == null) { Mass = 0; return; }
    var massinfo = Controller.CalculateShipMass();
    //Mass = massinfo.BaseMass;
    var cargoMass = massinfo.PhysicalMass - massinfo.BaseMass; // - massInfo.PhysicalMass(massinfo.TotalMass - massinfo.BaseMass) / CargoMult; // account for survival inventory multiplier
    //Mass += cargoMass;
    //Mass += ExtraMass; // in case TotalMass doesn't account for something somehow (strangely attached towed ships?  Rocks that aren't in an inventory?)
    Mass = massinfo.PhysicalMass;
    //scanlog.AppendLine("Mass: " + Mass + " kg");
    //scanlog.AppendLine("  Block: " + MassInfo.BaseMass.ToString("F0") + " kg");
    //scanlog.AppendLine("  Cargo: " + cargoMass.ToString("F1") + " kg");
    //scanlog.AppendLine("ExtraMass: " + ExtraMass.ToString("F0") + " kg");
    massChart.Text = "Mass: " + Mass + " kg"; massChart.Param = 2.6f;
    massChart.Text += "\n  Cargo: " + cargoMass.ToString("F1") + " kg";
    //if (CargoMult != 1f) massChart.Text += "\n(cargo x" + CargoMult + ')';
    //if (ExtraMass != 1f) massChart.Text += "\n(extra " + ExtraMass + " kg)";
  }

  static void UpdateMatrix()
  {
    if (Controller != null) // update from shipcontroller
    {
      Position = Controller.WorldMatrix.Translation;
      var Orientation = Quaternion.CreateFromRotationMatrix(Controller.WorldMatrix.GetOrientation());
      worldToShip = Quaternion.Conjugate(Orientation);
      // TODO if it's a remote, determine the configured "forward" direction
      posChart.Text = "Pos: " + Pretty._(Position); posChart.Param = Graph.row2fontsize;
      oriChart.Text = "Ori: " + Pretty._(Orientation); oriChart.Param = Graph.row2fontsize;
    }
  }

  // read gravity, orientation, and position, info about planet if any.  Called each Tick.
  public static void Update()
  {
    if (Controller == null || !Controller.IsUnderControl)
      FindController();
    if (Controller == null) 
    { // can survive without it
      Log.Output("No active controller in group!");
      return;
    }
    UpdateMass();
    UpdateMatrix();
    AnalyzeMotion();
    gravity.Update(Controller, worldToShip);
  }

  static void AnalyzeMotion()
  {
    if (Controller == null) { AngularVelocity = LinearVelocity = LinearAcceleration = new Vector3(); return; }
    MyShipVelocities vels = Controller.GetShipVelocities();
    AngularVelocity = vels.AngularVelocity;
    LinearAcceleration = (vels.LinearVelocity - LinearVelocity) / Time.dts;
    LinearVelocity = vels.LinearVelocity;
    velChart.Text = "Vel: " + Pretty._(LinearVelocity); velChart.Param = Graph.row2fontsize;
    rotChart.Text = "Rot: " + Pretty._(AngularVelocity); rotChart.Param = Graph.row2fontsize;
  }

  static List&lt;IMyShipController&gt; Controllers = new List&lt;IMyShipController&gt;();
}

// ROTION
// Manages orientation, rotation, angular velocity, and torque
public static class Rotion
{
  public static Module Init()
  {
    Chart.Title["turn"] = turnChart;
    var m = new Module(); m.Name = "Rotion"; m.Scan = Rescan; m.Tick = Update; m.Parse = Parse; m.Save = Save; return m;
  }

  public const double deg2rad = Math.PI / 180; // see VRageMath.MathHelper.ToRadians(1)  // FIXME move to Utility
  public const double rad2deg = 180 / Math.PI; // see VRageMath.MathHelper.ToDegrees(1)
  public static double RPMLimit = 60; // can reduce to slow ship rotation globally when under script control
  public static double TotalTorque; // of entire vessel, combined, best estimate, in kN

  public static Chart turnChart = new Chart();

  // disable gyro overrides and allow default angular damping to bring vessel to a stop
  public static void NoTurnVessel()
  {
    Explain(Vector3.Zero, "free");
    foreach (var gyro in Gyros)
      TurnGyro(gyro, new Vector3(), false);//, 0f);
  }

  public static float RotCapOnAxis(Vector3 axis) // returns available torque along that axis, in N, assumes axis is unit length
  {
    return (float)(TotalTorque * 1000); //(TotalTorque.Dot(axis) * 1000);
  }

  // takes vessel-local desired angular velocity vector
  public static void RotateVessel(Vector3 lrot)
  {
    if (lrot.LengthSquared() &gt; 1e-6f) TurnVessel(lrot, "rot");
    else NoTurnVessel();
  }
  // takes vessel-local desired angular velocity vector
  // request vessel to rotate at the stated local angular velocities, ASAP.
  // Gyros respond slowly though.  Changing settings often is a bad idea.
  static DateTime nextSteeringTime = DateTime.Now;
  public static readonly TimeSpan steeringUpdatePeriod = Time.Frequency(10);
  public static void TurnVessel(Vector3 lrot, string why = "turn")
  {
  //  if (DateTime.Now &lt; nextSteeringTime) return; // STOP FIDDLING with the sliders constantly - global sync version is not ideal
    var largest = lrot.Length();
  //  var mini = largest * .15f; // threshold relative to scale of vector as a whole
  //  if (Math.Abs(lrot.X) &lt; mini) lrot.X = 0; // flush proportionally small non-primary-axis fiddly manipulations to zero
  //  if (Math.Abs(lrot.Y) &lt; mini) lrot.Y = 0;
  //  if (Math.Abs(lrot.Z) &lt; mini) lrot.Z = 0;
    Explain(lrot, why);
    //rot *= new Vector3I(0,0,0); if (rot.LengthSquared() &lt; 1e-4f) return; // DEBUG
    var maxr = (float)RPMLimit * MathHelper.RPMToRadiansPerSecond;
    lrot = Vector3.Clamp(lrot, Vector3.MinusOne * maxr, Vector3.One * maxr);
    lrot = Vessel.ShipToWorldDir(lrot);
    var steerseconds = steeringUpdatePeriod.TotalSeconds;
    //var nbuckets = Math.Max(1, (int)(Time.UpdatePeriod.TotalSeconds / steerseconds));
    //var gyrosperbucket = Gyros.Count / nbuckets;
    //var updatebucket = (int)((nextSteeringTime - DateTime.Now).TotalSeconds * nbuckets / steerseconds);
    //var glo = updatebucket * gyrosperbucket; var ghi = glo + gyrosperbucket - 1;
    int i = 0;
    foreach (var gyro in Gyros)
    {// FIXME this logic cannot prevent low # of gyros from being ticked too often if ratio is too extreme
    //  if (i &gt;= glo &amp;&amp; i &lt;= ghi) // only update gyros in bucket scheduled to update this tick
        TurnGyro(gyro, lrot, true);
      ++i;
    }
    if (DateTime.Now &gt;= nextSteeringTime) // next cycle yet?
      if (DateTime.Now &gt; (nextSteeringTime += steeringUpdatePeriod)) // increment.  Still too far behind?
        nextSteeringTime = DateTime.Now; // catch up
  }

  public static void AngularDampen(Vector3 mask, double v = .0001, double v2 = .04)
  {
    if (Vessel.AngularVelocity.LengthSquared() &gt; 2e-5f)
    { // cancel existing velocity, prevent overshoot/oscillation
      var localr = Vessel.WorldToShipDir(Vessel.AngularVelocity) * mask;
      localr *= -(float)(v2*localr.Length() + v); // correct proportionally to error and its square
      if (localr.LengthSquared() &gt; 1e-6) { TurnVessel(localr, "damp"); return; }
    }
    NoTurnVessel();
  }

  static void Explain(Vector3 r, string why)
  {
    turnChart.Text = "Turning: " + why + '\n'
     + Pretty.MultiLine("r", r * (float)rad2deg, " /s") //? no
    //+ Pretty._(r) + " radian/s"
    //+ Pretty.Radians(r) + "/s"
      ; turnChart.Param = 1.2f; // fit 4 rows
  }

  static string[] Save()
  {
    return new string[] {
      "gyrolimitrpm=" + RPMLimit,
    };
  }

  static bool Parse(string[] tokens)
  {
    if (tokens.Length == 1)
    {
      string varn = tokens[0];
      if (varn == "stop" || varn == "reset") NoTurnVessel();
      else return false;
    } else {
      double val;
      if (!double.TryParse(tokens[1], out val)) return false;
      string varn = tokens[0];
         if (varn == "gyrolimitrpm" &amp;&amp; val &gt;= 0) RPMLimit = val;
      else return false;
    }
    return true;
  }

  static void Update()
  {
  //  Log.Output(turnChart.Text);
  }

  static bool Rescan()
  {
    Gyros.Clear(); GyroUpdate.Clear(); TotalTorque = 0;
    Scanner.GetBlocksOfType(Gyros);
    foreach (var g in Gyros) InitGyro(g);
    if (Gyros.Count == 0) // need gyros to function normally, but otherwise we can still display orientation.
      Log.scan.AppendLine("No gyros found in group!");
    return true; // NOT FATAL // Gyros.Count &gt; 0; // should make sure at least some are functioning
  }

  const float SmallGyroTorque = 1.35e5f; // measured by competition with a rotor
  const float LargeGyroTorque = 1.35e7f;

  static void InitGyro(IMyGyro g)
  {
    if (propGyroOverride == null)
    {
      propGyroOverride = g.GetProperty("Override").AsBool(); // for setting 
      propGyroPitch = g.GetProperty("Pitch").AsFloat();
      propGyroYaw   = g.GetProperty("Yaw"  ).AsFloat();
      propGyroRoll  = g.GetProperty("Roll" ).AsFloat();
    }
    GyroUpdate[g] = DateTime.Now;
    //g.BlockDefinition.SubtypeId // TODO account for modded gyros FIXME account for off-grid gyros/leverage on main center of mass
    var gtorque = g.CubeGrid.GridSize &lt; 1 ? SmallGyroTorque : LargeGyroTorque;
    gtorque *= g.GyroPower;
    TotalTorque += gtorque;
    //Log.scan.AppendLine("'" + g.CustomName + "' at " + (int)(g.GyroPower*100) + '%'
    //  + "rated " + propGyroYaw.GetMaximum(g)*MathHelper.RadiansPerSecondToRPM + " RPM"); 
  }

  const float tiny = .05f;
  const float mindeltafraction = .05f;

  // rot is a world rotation axis scaled by rotation rate in radians/second
  // (an angular velocity vector)
  // Pitch = noseup = ccw x, Yaw = noseleft = ccw y, Roll = ccw z
  static void TurnGyro(IMyGyro g, Vector3 v, bool overrideg) //, float tickphase)
  {
    if (!overrideg &amp;&amp; propGyroOverride.GetValue(g)) {
      propGyroPitch.SetValue(g, 0f);
      propGyroYaw.SetValue(g, 0f);
      propGyroRoll.SetValue(g, 0f);
    }
    propGyroOverride.SetValue(g, overrideg);
    var nextupdate = GyroUpdate[g];
    if (nextupdate &gt; DateTime.Now) return;
    if (overrideg)
    { // must not care what set to when not overridden
      Matrix mworld = g.WorldMatrix.GetOrientation(); // gyro to world
      mworld.TransposeRotationInPlace(); // now world to gyro
      v = Vector3.Transform(v, ref mworld); // now gyro local
      v *= new Vector3I(1, -1, -1); // gyros have backward conventions for angular directions on certain axes, versus how it works out with cross products.
      bool changed = false;
      float mindf = mindeltafraction, tinyf = tiny;
      // always update if past time, else only if delta large enough
      if (nextupdate &lt; DateTime.Now - steeringUpdatePeriod) mindf = tinyf = 0f;
      v *= MathHelper.RadiansPerSecondToRPM; // FIX for recent api change
      changed |= Utility.SetWithMinDelta(propGyroPitch, g, v.X, tinyf, mindf);
      changed |= Utility.SetWithMinDelta(propGyroYaw,   g, v.Y, tinyf, mindf);
      changed |= Utility.SetWithMinDelta(propGyroRoll,  g, v.Z, tinyf, mindf);
      if (changed) GyroUpdate[g] = DateTime.Now + steeringUpdatePeriod;
    }
  }

  static List&lt;IMyGyro&gt; Gyros = new List&lt;IMyGyro&gt;();
  static Dictionary&lt;IMyGyro, DateTime&gt; GyroUpdate = new Dictionary&lt;IMyGyro, DateTime&gt;(); // do not update until

  static ITerminalProperty&lt;bool&gt; propGyroOverride; // gyro
  static ITerminalProperty&lt;float&gt; propGyroPitch, propGyroYaw, propGyroRoll; // units radian/s, displayed units RPM
}

// MOTION
// Position / Linear Velocity management by thruster overrides
public static class Motion
{
  public static Module Init()
  {
    Chart.Title["tcap"] = thrustCapChart;
    Chart.Title["tovr"] = thrustOvrChart;
    var m = new Module(); m.Name = "Motion"; m.Scan = Rescan; m.Tick = Update; m.Parse = Parse; m.Save = Save; return m;
  }
  
  public static double AccelerationLimit = 50; // in G
  public static double VelocityLimit = 100; // in m/s

  public static Chart thrustCapChart = new Chart(); // total thruster capability in 6 local directions -x,-y,-z;+x,+y,+z  -L,-D,-F;+R,+U,+B
  public static Chart thrustOvrChart = new Chart(); // thruster overrides

  static bool Rescan()
  {
    Thrusts.Clear();
    if (Vessel.Controller != null &amp;&amp; !Vessel.Controller.ControlThrusters)
      Log.scan.AppendLine("Not controlling thrusters."); 
    Scanner.GetBlocksOfType(Thrusts);
    foreach (var t in Thrusts) InitThrust(t);
    ComputeThrustCap();
    //if (Thrusts.Count == 0 || (ingravity &amp;&amp; !enoughthrusttosupportmass)) warningmessage(); // TODO should make sure at least some are functioning, that we have enough directional coverage and can support ourselves in gravity
    return true;
  }

  public static float ThrustCapInDirection(Vector3 localdir) // thrust capability along local direction, in N, assumes localdir is in unit box, not necessarily unit length
  {
    return 1000 * localdir.Dot(new Vector3(
      localdir.X &lt; 0 ? ThrustCap.Min.X : ThrustCap.Max.X,
      localdir.Y &lt; 0 ? ThrustCap.Min.Y : ThrustCap.Max.Y,
      localdir.Z &lt; 0 ? ThrustCap.Min.Z : ThrustCap.Max.Z));
  }
  public static Vector3 ThrustCapsInDirection(Vector3 localdir)
  {
    return 1000 * localdir * new Vector3(
      localdir.X &lt; 0 ? -ThrustCap.Min.X : ThrustCap.Max.X,
      localdir.Y &lt; 0 ? -ThrustCap.Min.Y : ThrustCap.Max.Y,
      localdir.Z &lt; 0 ? -ThrustCap.Min.Z : ThrustCap.Max.Z);
  }

  public static void ThrustVessel(Vector3 worldN, string why = "thrust") // world thrust vector in Newtons
  {
    var n2 = worldN.LengthSquared();
    if (n2 &lt; 1e-4f)
      NoMoveVessel();
    else {
      Vector3 ld = Vessel.WorldToShipDir(worldN);
      Vector3 lt = Vector3.Clamp(ld * .001f, ThrustCap.Min, ThrustCap.Max); // convert to kN
      ld = Vector3.Normalize(ld);
      var lsgn = Vector3.Sign(ld);
      var dirmax = Vector3.Max(new Vector3(), Vector3.Max(ThrustCap.Min * lsgn, ThrustCap.Max * lsgn)); // axial thrust potentials in direction
      Vector3 proportions = Vector3.Abs(lt / (dirmax + 1e-8f)); // thrust requested : available
      foreach (var thrust in Thrusts)
        ThrustThruster(thrust, proportions, ld);
      Explain(lt, why);
      //Log.Output("tld: " + Pretty._(ld));
      Log.Output("prop: " + Pretty._(proportions));
    }
  }

  public static void NoMoveVessel()
  {
    Explain(Vector3.Zero, "free");
    //Override = false;
    foreach (var thrust in Thrusts) {
      thrust.Enabled = true;
      propThrustOverride.SetValue(thrust, 0f);
    }
  }
  // respects configured limits
  // does not accounts for gravity influence, because
  // if you want the limits respected, and yet find yourself exceeding upward limit, want to fall down, duh!
  public static void AccelerateVessel(Vector3D accel, string why = "accel") // accel is in ship local coords in m/s
  {
    float accellimit = Vessel.Gravity.StandardG * (float)AccelerationLimit;
    if (VelocityLimit &gt;= 0 &amp;&amp; Vessel.Controller.GetShipSpeed() &gt; VelocityLimit)
    {
      var v = Vessel.LinearVelocity; var vl = v.Length();
      accel = Vessel.WorldToShipDir(v * (float)(-accellimit / vl));
      accel -= Vessel.gravity.Local;
      //Log.Output("slowing");
    }
    if (accel.LengthSquared() &gt; 1e-4f)
    {
      accel = Vector3.Clamp(accel, ThrustCap.Min, ThrustCap.Max); // doesn't matter
      accel = Vector3.Clamp(accel, Vector3.MinusOne * accellimit, Vector3.One * accellimit);
      Vector3D wt = Vessel.ShipToWorldDir(accel);
      //wt -= Vessel.gravity.World; // counter expected gravity acceleration - leave to higher level control code
      ThrustVessel(wt * Vessel.Mass, why); // thrust request in Newtons (kg*m/s) world space
    }
    else NoMoveVessel();
  }

  // Thrust vessel with its entire thrust capability in proportion to a player input ship local move request vector.
  public static void MoveVessel(Vector3 move)
  {
    //var dirmax = Vector3.Max(new Vector3(), 
    //  Vector3.Max(ThrustCap.Min * localdir, ThrustCap.Max * localdir)); // max thrust potential in direction
    var totalreq = Vector3.Clamp(move, Vector3.Zero, Vector3.One) * ThrustCap.Max;
    totalreq -= Vector3.Clamp(move, Vector3.MinusOne, Vector3.Zero) * ThrustCap.Min;
    if (totalreq.LengthSquared() &lt; 1e-4f)
      LinearDampen(Vector3.One); //, ThrustResponse1, ThrustResponse2);
    else
      AccelerateVessel(totalreq, "move"); // request in local m/s
  }

  public static void TargetVelocity(Vector3 v) // v in world m/s, try to obtain instantly
  {
    AccelerateVessel(Vessel.WorldToShipDir(v - Vessel.LinearVelocity) / Time.dts, "vel"); // request in local m/s
  }

  // compute force needed to reduce absolute ship velocity toward zero in world m/s
  public static Vector3 LinearDampeningAcc(double vdamp = .05f, double vdamp2 = .2f)
  {
    if (Vessel.Controller == null || Vessel.LinearVelocity.LengthSquared() == 0) return new Vector3();
    var wv = Vessel.LinearVelocity;
    // FIXME the only problem is this isn't accurate.  Need Exp(-rate*time) involved or otherwise prevent overshoot
    return wv * -(float)(vdamp2 * wv.Length() + vdamp); // correct proportionally to the error and square       
  }

  // override thrusters to reduce absolute ship velocity toward zero
  public static void LinearDampen(Vector3 localaxismask, double vdamp = .05f, double vdamp2 = .2f)
  {
    var f = new Vector3();
    if ((Vessel.Controller == null || Vessel.Controller.DampenersOverride)
      &amp;&amp; Vessel.LinearVelocity.LengthSquared() &gt; 1e-4f) // only when moving significantly, otherwise the built-in inertial dampeners do a better job
    f = localaxismask * Vessel.WorldToShipDir(LinearDampeningAcc(vdamp, vdamp2));
    AccelerateVessel(f, "damp"); // request in local m/s
  }

  static void Explain(Vector3 t, string why)  // local thrust in kN
  {
    string u = "m/s";
    //var tpct = t * (100 * ShipMass) / WorldToShipDir(wthrust); t = tpct; u = " %";
    //var gfrac = t / Vessel.Gravity.StandardG; t = gfrac; u = " G";
    thrustOvrChart.Text = "Thrusting: " + why + '\n'
      + Pretty.MultiLine("t", t, u)
    //+ Pretty._(t) + ' ' + u
      ; thrustOvrChart.Param = 1.2f; // fit 4 rows
  }

  static void Update()
  {
    Log.Output(thrustOvrChart.Text);
  }

  static string[] Save()
  {
    return new string[] {
      "thrustaccellimit=" + AccelerationLimit,
      "thrustvellimit=" + VelocityLimit,
    };
  }

  static bool Parse(string[] tokens)
  {
    string varn = tokens[0];
    if (tokens.Length == 1)
    {
      if (varn == "stop" || varn == "reset") NoMoveVessel();
      else return false;
    } else {
      double val;
      if (!double.TryParse(tokens[1], out val)) return false;
         if (varn == "thrustaccellimit" &amp;&amp; val &gt;= 0) AccelerationLimit = val;
      else if (varn == "thrustvellimit" &amp;&amp; val &gt;= 0) VelocityLimit = val;
      else return false;
    }
    return true;
  }

  static void InitThrust(IMyThrust thrust)
  {
    if (propThrustOverride == null) propThrustOverride = thrust.GetProperty("Override").AsFloat(); 
  }

  // Helps encapsulate quirks regarding overriding of SE thruster blocks.
  // If overriding, opposing directions must have at least a minimum amount of override, to prevent them from firing inertial damping and fighting us, adding slew
  // So we need a way to disable the builtin inertial dampening, on certain thrusters at least; perhaps the cockpit setting would work.  But that's beside the point.
  // If fraction is &lt; 0, disables OVERRIDE, leaves block on but uncontrolled, performing inertial dampening.
  // If fraction is == 0, or &lt;= .01, the thruster block will be TURNED OFF.  The game won't allow setting tiny overrides, flushes them to zero, which we don't want.
  // if &gt; .01, turn on and sets override percentage to clipped fraction*100
  static void OverrideThruster(IMyThrust thrust, float fraction)
  {
    if (fraction &lt; 0) { // invalid request results in standard uncontrolled inertial dampening behavior, not overridden.
      thrust.Enabled = true;
      propThrustOverride.SetValue(thrust, 0);
    }
    else if (fraction &lt;= .01) { // off.  Tiny overrides cannot be achieved.  Prevent builtin inertial dampening after game clips them to zero.
      thrust.Enabled = false;
    }
    else { // on.  Set percentage.
      thrust.Enabled = true;
      propThrustOverride.SetValue(thrust, Math.Min(1f, fraction) * thrust.MaxEffectiveThrust); // now in Newtons
      //propThrustOverride.SetValue(thrust, Math.Min(1f, fraction) * 100); // was a percentage!  sigh
    }
  }

  static void ThrustThruster(IMyThrust thrust, Vector3 proportions, Vector3 localdir)
  { 
    var tworlddir = thrust.WorldMatrix.Backward;
    var tlocaldir = Vessel.WorldToShipDir(tworlddir);
    var dot = localdir.Dot(tlocaldir); // in ship space, how well does thruster line up with TOTAL requested thrust vector?  turns out, not particularly useful.
    var vdot = tworlddir.Dot(Vessel.LinearVelocity);
    //var tridot = tlocaldir * tlocaldir; // trilinear from normal?  This way if it's 45, will contribute 50% both ways, otherwise would be  +  = 2 = TOO MUCH when totalled with thrusts on other side
    //var propm = proportions * tlocaldir;
    //var prop2 = proportions.Dot(tridot);
    var amt = dot;
    var signsv = Vector3.Sign(tlocaldir * localdir);
    //var signsa = signsv.Min() &gt;= 0; // 0 if contrary to any desired thrust direction, else 1
    var signsb = signsv.Max(); // 1 if at least partially aligned with the desired thrust direction, else &lt;= 0
    var signsc = signsb &gt; 0; // 1 if at least partially aligned with the desired thrust direction, else 0
    var propd = proportions.Dot(Vector3.Abs(tlocaldir)) * signsb; // which proportion axes does this thruster best represent in combination?
    //amt *= Math.Abs(amt); // square signed
    // choose cutoff threshold to prevent malaligned thrusters from firing at all but when near 45 2 directions will fire
    // BUT if threshold isn't zero, it's possible we won't get any thrust at all despite having some thrusters kind-of lined up;
    // In particular threshold of .5 was causing loss of altitude due to ignoring antigravity thrust when thrusting stronger horizontally.
    // Decide if this thruster will be more useful than it will be detrimental to our request.
    const double cutoffdot = 0; //-.5; //-1; //-0.087; // cos(95)
    if (signsc &amp;&amp; dot &gt; cutoffdot) 
      amt = propd; // may want to fade out by dot but be careful not to cut needed thrusts!
    else //if (dot &lt; -.087f &amp;&amp; vdot &lt; 0) // opposing thrust dir AND motion    // FIXME something wrong here is breaking damping
      amt = 0f; // just turn it off
    //else // neither - only force something if it's contrary to desired thrusting; otherwise let builtin dampening handle this thruster
    //  amt = -1f; // don't override perpendicular thrusters
    //var amt_kN = amt * thrust.MaxThrust;
    //Log.Output("t: " + thrust.CustomName + ": amt=" + amt + " propd=" + propd + " dot=" + dot + " sb=" + signsb);  //  + " sa=" + signsa
    OverrideThruster(thrust, amt);
  }

  static void ComputeThrustCap() // into ThrustCap
  {
    SignedSum(Thrusts.ConvertAll(AvailableThrust), out ThrustCap);
    ThrustCap.Min *= .001f; ThrustCap.Max *= .001f; // to kN
    #if true  // in kN 
    thrustCapChart.Text = "thr-: " + Pretty._(ThrustCap.Min) + "\nxyz+; " + Pretty._(ThrustCap.Max) + " kN";
    #else // as G fraction
    float tofrac = (float)(Vessel.Gravity.StandardG * 1000 / Vessel.Mass);  // as fraction of ship mass vs 1G, account for kN conversion vs. kg mass
    thrustCapChart.Text = "thr-: " + Pretty._(ThrustCap.Min*tofrac) + "\nxyz+; " + Pretty._(ThrustCap.Max*tofrac) + " G";
    #endif
    Log.scan.AppendLine(thrustCapChart.Text);
    //foreach (var t in Thrusts) Log.scan.AppendLine("'" + t.CustomName + "' rated " + Pretty._(t.MaxThrust * .001f) + " kN"); 
  }

  static Vector3 AvailableThrust(IMyThrust t) // result is ship local Newtons
  {
    return Vector3.Normalize(Vessel.WorldToShipDir(t.WorldMatrix.Backward)) * t.MaxEffectiveThrust; //.MaxThrust; //
  }

  // accumulate thrust in 6 directions at once
  static void SignedSum(IEnumerable&lt;Vector3&gt; vs, out BoundingBox o)
  {
    Vector3 zero = new Vector3(), lo = zero, hi = zero;
    foreach (var v in vs) {
      var neg = Vector3.Min(zero, v);
      var pos = Vector3.Max(zero, v); //v - neg;
      lo += neg; hi += pos; 
    }
    o.Min = lo; o.Max = hi;
  }

  static List&lt;IMyThrust&gt; Thrusts = new List&lt;IMyThrust&gt;();

  static BoundingBox ThrustCap; // kilo Newtons force potential all 6 directions in ship space 
  static ITerminalProperty&lt;float&gt; propThrustOverride; // thrust, Override is a Percentage (0 to 100)
}

// UPRIGHT
// Keeps Vessel down vector aligned with gravity.
// Uses Rotion module to manage the gyroscope overrides.
public static class Upright
{
  public static Module Init()
  {
    Chart.Title["pitch"] = PitchChart;
    Chart.Title["roll" ] = RollChart;
    Chart.Title["yaw"  ] = YawChart;
    Chart.Title["steer"] = SteerChart;
    var m = new Module(); m.Name = "Upright"; m.Tick = Update; m.Parse = Parse; m.Save = Save; return m;
  }
  public static float PitchOffsetDegrees = 0; // allows ship to maintain different pitch attitudes
  public static float PitchTiltDegrees = 0; // for use by Hover module to temporarily tilt the ship
  public static float PitchTiltMaxDegrees = 60; // limits +/- PitchTiltDegrees

  public static float PitchAngleClipDegrees = .05f; // in degrees - the better pitch is aligned, the less roll will become misaligned
  public static float  RollAngleClipDegrees = .03f; // in degrees - match roll precisely if possible, but don't fidget over micro-degrees
  public static float PitchAngleSlopDegrees = .1f; // in degrees
  public static float  RollAngleSlopDegrees = .1f; // in degrees
  // once it goes past clip + slop limit, it will begin to correct toward the clip boundary
  // I find that, since the gyros have their own internal PID controller, using only Proportional
  // response works best (with limiting for stopping distance)
  public static float ResponseP2 = 1; //4; // factor proportional to square of error
  public static float ResponseP = 10; // factor converting misalignment (sine) into angular radians/s; overall corrector stiffness; (was GyroSpeedScale)
  public static float ResponseI = .1f; // integral factor
  public static float ResponseD = 0; //.1; // forced damping counter to existing velocity, to counter overcorrection and oscillation on massive ships
  public static float ResponseD2 = .1f; //1.4; // proportional to square of angular velocity, works much better for my purposes than using first derivative
  public static float ThresholdBoundaryBoost = .001f;
  public static float Stoppability = 2e-5f; // for estimating stopping power TODO estimate from gyros and ship mass
  public static float Sensitivity = 1; // input sensitivity 
  public static float PitchSensitivity = .2f; // input sensitivity for pitch

  static PIDControllerFloat GyroControllerPitch = new PIDControllerFloat();
  static PIDControllerFloat GyroControllerRoll = new PIDControllerFloat();

  public static Chart PitchChart = new Chart();
  public static Chart RollChart = new Chart();
  public static Chart YawChart = new Chart();
  public static Chart SteerChart = new Chart();

  public static Vector3 Down() // local
  {
    double a = Rotion.deg2rad * (PitchOffsetDegrees + MathHelper.Clamp(PitchTiltDegrees, -PitchTiltMaxDegrees, PitchTiltMaxDegrees));
    return new Vector3D(0, -Math.Cos(a), Math.Sin(a));
  }
  public static Vector3 CurrentAngles() // in radians
  {
    Vector3 cross = Vector3.Cross(Down(), Vessel.gravity.LocalDir); // perpendicular to both AlignDir and gravity in ship local space
    return new Vector3(Math.Asin(cross.X), Math.Asin(cross.Y), Math.Asin(cross.Z)); // convert sines to radian angles
  }
  public static float CurrentPitch() { return -CurrentAngles().X; }

  static void Update()
  {
    var c = Vessel.Controller;
    if (c == null) return;
    if (Vessel.gravity.Strength &lt; .01)
    {
      PitchChart.Text = RollChart.Text = YawChart.Text = "No gravity.";
      PitchChart.Param = RollChart.Param = YawChart.Param = 2f;
      return;
    }
    var localr = Vessel.WorldToShipDir(Vessel.AngularVelocity); // to local space, radians/s
    var angles = CurrentAngles();
    const double border = 2; //  border
    double limx = Rotion.deg2rad * (PitchAngleClipDegrees+PitchAngleSlopDegrees), lim2x = limx + Rotion.deg2rad*border;
    double limz = Rotion.deg2rad * ( RollAngleClipDegrees+ RollAngleSlopDegrees), lim2z = limz + Rotion.deg2rad*border;
    PitchChart.Text = "Pitch: " + Pretty.Radians(-angles.X) + '\n' + Graph.Limit(-angles.X, limx, lim2x, Graph.smChartWidth);
    RollChart .Text = "Roll:  " + Pretty.Radians(-angles.Z) + '\n' + Graph.Limit(-angles.Z, limz, lim2z, Graph.smChartWidth);
    YawChart  .Text = "Yaw:   " + Pretty.Radians(-angles.Y) + '\n' + Graph.Limit(-angles.Y, 0, MathHelper.TwoPi, Graph.smChartWidth);
    PitchChart.Param = RollChart.Param = YawChart.Param = Graph.row2fontsize; // only need 2 lines
    var clippedlimits = angles;
    clippedlimits.X = (float)Utility.DeadZone(clippedlimits.X, PitchAngleClipDegrees * Rotion.deg2rad);
    clippedlimits.Z = (float)Utility.DeadZone(clippedlimits.Z,  RollAngleClipDegrees * Rotion.deg2rad);
    bool pastlimit = Math.Abs(clippedlimits.X) &gt; PitchAngleSlopDegrees * Rotion.deg2rad || Math.Abs(clippedlimits.Z) &gt; RollAngleSlopDegrees * Rotion.deg2rad;
    var response = -clippedlimits;
    response.X = (float)Utility.BoostZone(response.X, ThresholdBoundaryBoost);
    response.Z = (float)Utility.BoostZone(response.Z, ThresholdBoundaryBoost);
    // since the Targets were never set, they're still at zero always. 
    GyroControllerPitch.Kp2 = GyroControllerRoll.Kp2 = (float)ResponseP2;
    GyroControllerPitch.Kp = GyroControllerRoll.Kp = (float)ResponseP;
    GyroControllerPitch.Ki = GyroControllerRoll.Ki = (float)ResponseI;
    GyroControllerPitch.Kd = GyroControllerRoll.Kd = (float)ResponseD;
    GyroControllerPitch.Kd2= GyroControllerRoll.Kd2= (float)ResponseD2;
    response.X = GyroControllerPitch.Advance(Time.dts, response.X);
    response.Z = GyroControllerRoll .Advance(Time.dts, response.Z);
    //response *= (float)-2 / (1.001 - Vessel.gravity.LocalDir.Y); // nonlinear remap for more oomph when totally flipped over, careful when perfectly upside-down though!
    var rim = (float)(Stoppability / Vessel.Mass);  // do not overestimate vessel's ability to reduce its own rotation! or becomes unstable.
    //Log.Output("rim: " + rim);
    response.X = Utility.ClampAbs(response.X, PIDControllerFloat.MaxVelocityForDistanceStoprate(Math.Abs(clippedlimits.X), Rotion.RotCapOnAxis(Vector3.Right   ) * rim));
    response.Z = Utility.ClampAbs(response.Z, PIDControllerFloat.MaxVelocityForDistanceStoprate(Math.Abs(clippedlimits.Z), Rotion.RotCapOnAxis(Vector3.Backward) * rim));
    var uactive = Vessel.Controller != null &amp;&amp; Vessel.Controller.IsUnderControl;
    var s = Sensitivity;
    float steeringYaw = c.RotationIndicator.Y * s;
    float steeringPitch = c.RotationIndicator.X * PitchSensitivity;
    float steeringRoll = c.RollIndicator * s;
    if (uactive)
    {
      var sv = Vessel.gravity.LocalDir * steeringYaw; // mix in user yaw around gravity vector (NOT ship Y) - should reverse if upside down?
      // anyway it won't be stable over time, but if updated each frame this is the right thing to do.
      // only allow inputs that don't fight correction
      if (steeringPitch * response.X &lt;= float.Epsilon) sv.X -= steeringPitch;
      if (steeringRoll * response.Z &lt;= float.Epsilon) sv.Z -= steeringRoll;
      response += sv;
    }
    var yawgraph = "Yaw:  " + Pretty._(steeringYaw) + '\n' + Graph.Limit(steeringYaw, 9, 12, Graph.smChartWidth);
    YawChart.Text += "\n" + yawgraph;
    SteerChart.Text = yawgraph;
    SteerChart.Text += "\nPitch:  " + Pretty._(steeringPitch) + '\n' + Graph.Limit(steeringPitch, 9, 12, Graph.smChartWidth);
    SteerChart.Text += "\nRoll:  " + Pretty._(steeringRoll) + '\n' + Graph.Limit(steeringRoll, 1, 1.3, Graph.smChartWidth);
    SteerChart.Param = 1.2f; // fit 4 rows
    PitchChart.TextColor = Graph.StatusColor(Math.Abs(response.X));
     RollChart.TextColor = Graph.StatusColor(Math.Abs(response.Z));
      YawChart.TextColor = Graph.StatusColor(Math.Abs(response.Y));
    Rotion.TurnVessel(response, "align"); // given ship controller local coords
  }

  static bool Parse(string[] tokens)
  {
    string varn = tokens[0];
    if (tokens.Length == 1)
    {
      if (varn == "stop" || varn == "reset")
        Rotion.NoTurnVessel(); 
      else return false;
    }
    else
    {
      double val;
      if (!double.TryParse(tokens[1], out val)) return false; var vf = (float)val;
      if (varn == "pitchoffsetdegrees" || varn == "pitchofs") // legacy name - TODO REMOVE
        PitchOffsetDegrees = MathHelper.ToDegrees(MathHelper.WrapAngle(MathHelper.ToRadians((float)val)));
      else if (varn == "tiltmaxdegrees" &amp;&amp; vf &gt;= 0)
        PitchTiltMaxDegrees = vf;
      else if ((varn == "pitchangleclipdegrees" || varn == "pitchclip") &amp;&amp; vf &gt;= 0)
        PitchAngleClipDegrees = vf;
      else if ((varn == "rollangleclipdegrees" || varn == "rollclip") &amp;&amp; vf &gt;= 0)
        RollAngleClipDegrees = vf;
      else if ((varn == "pitchangleslopdegrees" || varn == "pitchslop") &amp;&amp; vf &gt;= 0)
        PitchAngleSlopDegrees = vf;
      else if ((varn == "rollangleslopdegrees" || varn == "rollslop") &amp;&amp; vf &gt;= 0)
        RollAngleSlopDegrees = vf;
      else if (varn == "steeringsensitivity" &amp;&amp; vf &gt;= 0)
        Sensitivity = vf;
      else if (varn == "pitchsensitivity" &amp;&amp; vf &gt;= 0)
        PitchSensitivity = vf;
      else if (varn == "gyrostoppability" &amp;&amp; vf &gt;= 0)
        Stoppability = vf;
      else if (varn == "alignangularresponsep2")
        ResponseP2 = vf;
      else if (varn == "alignangularresponsep")
        ResponseP = vf;
      else if (varn == "alignangularresponsei")
        ResponseI = vf;
      else if (varn == "alignangularresponsed")
        ResponseD = vf;
      else if (varn == "alignangularresponsed2")
        ResponseD2 = vf;
       else return false;
    }
    return true;
  }

  static string[] Save()
  {
    return new string[] {
      "pitchoffsetdegrees=" + PitchOffsetDegrees,
      "tiltmaxdegrees=" + PitchTiltMaxDegrees,
      "pitchangleclipdegrees=" + PitchAngleClipDegrees,
      "rollangleclipdegrees=" + RollAngleClipDegrees,
      "pitchangleslopdegrees=" + PitchAngleSlopDegrees,
      "rollangleslopdegrees=" + RollAngleSlopDegrees,
      "steeringsensitivity=" + Sensitivity,
      "pitchsensitivity=" + PitchSensitivity,
      "gyrostoppability=" + Stoppability,
      "alignangularresponsep2=" + ResponseP2,
      "alignangularresponsep=" + ResponseP,
      "alignangularresponsei=" + ResponseI,
      "alignangularresponsed=" + ResponseD,
      "alignangularresponsed2=" + ResponseD2,
    }; 
  }
}

// PLANET
// scans useful info about planet using Vessel controller
public static class Planet
{
  public static Module Init()
  {
    var m = new Module(); m.Name = "Planet"; m.Scan = Rescan; m.Tick = Update; return m;
  }

  public static bool Detected { get { return Radius &gt; 0; } }
  public static Vector3D Center;
  public static float Radius; public static float Sealevel { get { return Radius; } }
  public static double Altitude; // above mean Sealevel (MSL) 
  public static double Height; // from Surface (AGL), unfiltered
  public static double Elevation; // of the local terrain (guess, slightly filtered)

  static bool Rescan()
  {
    Radius = 0;
    var c = Vessel.Controller;
    if (c == null)
    {
      Log.Output("No controller!");
      sizeChart.Text = posChart.Text = angleChart.Text = altChart.Text = elevChart.Text = hgtChart.Text = "Misconfigured!";
      return true; // not fatal
    }
    if (Vessel.gravity.Strength &lt; .01)
    {
      sizeChart.Text = posChart.Text = angleChart.Text = altChart.Text = elevChart.Text = hgtChart.Text = "No planet detected";
      return true;
    }
    Center = Vector3D.Zero;
    if (c.TryGetPlanetPosition(out Center))
    {
      posChart.Text = "Planet center GPS:\n" + Pretty._(Center);
      double dc = (Vessel.Position - Center).Length();
      if (c.TryGetPlanetElevation(MyPlanetElevation.Sealevel, out Altitude) &amp;&amp; c.TryGetPlanetElevation(MyPlanetElevation.Surface, out Height))
      {
        Radius = (float)(dc - Altitude); // calculate sea level
        sizeChart.Text = "Planet\nRadius: " + Pretty._((float)(Radius * .001)) + " km";
        Elevation = Altitude - Height; // reset filter
      }
    }
    Log.diagnostic.AppendLine(posChart.Text); // written to CustomData for easy copy&amp;paste
    Chart.Title["size"] = sizeChart;
    Chart.Title["pos"] = posChart;
    return true;
  }

  static void Update()
  {
    var c = Vessel.Controller;
    if (c == null)
    {
      Log.Output("No controller!");
      sizeChart.Text = angleChart.Text = altChart.Text = posChart.Text = "Misconfigured!";
      return;
    }
    double dc = (Vessel.Position - Center).Length();
    if (c.TryGetPlanetElevation(MyPlanetElevation.Sealevel, out Altitude) &amp;&amp; c.TryGetPlanetElevation(MyPlanetElevation.Surface, out Height))
    {
      hgtChart.Text = "Height: " + Pretty._((float)Height) + " m";
      altChart.Text = "Altitude: " + Math.Abs((int)Altitude) + " m\n " + (Altitude &gt; 0 ? "above" : "below") + " sealevel";
      elevChart.Text = "Elevation: " + (int)Elevation + " m\n of local terrain";
    }
    if (Height &lt; 0) hgtChart.Text += "\nOuch!! Are we alive?!";
    var rel = Vector3D.Normalize(Vessel.Position - Center);
    // using +Y as North
    var longitude = Math.Atan2(rel.X, rel.Z);
    var latitude = Math.Asin(rel.Y);
    angleChart.Text = "longitude: " + Pretty.Radians((float)Math.Abs(longitude)) + (longitude &gt; 0 ? 'E' : 'W');
    angleChart.Text += "\nlatitude: " + Pretty.Radians((float)Math.Abs(latitude)) + (latitude &gt; 0 ? 'N' : 'S');
    float alterr = (float)MathHelper.Saturate(.5 - .002 * Altitude); // .5 at 0, 1 at 250m below, 0 at 250m above
    float hgterr = Height &gt; 250 ? 0f : (float)Math.Max(.01, 1 - MathHelper.Saturate((Height-10) / 100));
    float err = Math.Max(alterr, hgterr);
    sizeChart .UpdateColor(0); sizeChart.Param = 2.4f;
    posChart  .UpdateColor(0); posChart.Param = 1.6f;
    angleChart.UpdateColor(0); angleChart.Param = 2.0f;
    altChart  .UpdateColor(alterr); altChart.Param = 2.4f;
    hgtChart  .UpdateColor(hgterr); hgtChart.Param = 2.6f;
    elevChart .UpdateColor(err); elevChart.Param = 2.2f;
    
    Chart.Title["angle"] = Chart.Title["long"] = Chart.Title["lati"] = angleChart;
    Chart.Title["alt"] = altChart;
    Chart.Title["elev"] = elevChart;
    Chart.Title["heig"] = hgtChart;
  }

  public static void PickCompactChart() // only if is the main module
  {
    Chart whichChart;
    switch (Time.gms / 3000 % 9)
    { // periodically toggle between them
      default:
      case 0: whichChart = Chart.Logo; break;
      case 1: whichChart = posChart; break;
      case 2: whichChart = sizeChart; break;
      case 3: whichChart = Vessel.gravity.gravChart; break;
      case 4: whichChart = altChart; break;
      case 5: whichChart = angleChart; break;
      case 6: whichChart = hgtChart; break;
      case 7: whichChart = elevChart; break;
      case 8: whichChart = Chart.Standard; break;
    }
    if (true) Chart.Subtype["Corner"] = whichChart; 
  }

  static Chart sizeChart = new Chart();
  static Chart posChart = new Chart();
  static Chart angleChart = new Chart();
  static Chart altChart = new Chart();
  static Chart elevChart = new Chart();
  static Chart hgtChart = new Chart();
}

// SLOPE
// Measures approximate slope of terrain under the Vessel.
// Depends on Planet module for altitude/height, and Vessel module.
public static class Slope
{
  public static Module Init()
  {
    Chart.Title["slope"] = slopeChart;
    var m = new Module(); m.Name = "Slope"; m.Tick = Update; m.Parse = Parse; m.Save = Save; return m;
  }

  public static float TiltPower = .25f; // how strongly terrain slope affects pitch tilt
  public static float EstimateRadians; // slope estimate in radians (0 is flat level terrain, 1.57 is a cliff)

  public static Chart slopeChart = new Chart();

  static void Update()
  {
    if (Vessel.gravity.Strength &lt; .01) return;
    var gw = Vessel.gravity.WorldDir;
    var linvelg = Vessel.LinearVelocity.Dot(gw); // velocity in gravity direction
    var linvelnog = Vessel.LinearVelocity - gw*linvelg; // reject to find velocity not in gravity direction
    if (linvelnog.LengthSquared() &gt; 1e-2f) // can only update if moving enough to measure a height delta
    {
      //var undelta = 1 / Time.dts;
      var shipToWorld = Vessel.shipToWorld;
      // compute terrain gradient
      var gfw =  Vector3.Normalize(shipToWorld.  Right.Cross(gw));
      //var grt = -Vector3.Normalize(shipToWorld.Forward.Cross(gw));
      oldheight -= linvelg * Time.dts;// bring our oldheight estimate up to present time to account for our own vertical motion, which would otherwise bias the result
      var fwspeed = linvelnog.Dot(gfw); //linvelnog.Length(); //
      var fwprog = fwspeed * Time.dts;
      double newestimate = (oldheight - Planet.Height) / fwprog; // so far just a ratio of height to length
      newestimate = Math.Atan(newestimate); // sin/cos =&gt; radian angle
      oldheight = (float)Planet.Height;
      // TODO filter should be slower at high altitude
      // slow lowpass filter by distance ignores tiny bumps; we must move a ways before it will update
      newestimate = MathHelper.Lerp(newestimate, EstimateRadians, Math.Exp(-.5*Math.Abs(fwspeed)*Time.dts)); 
      newestimate *= Math.Exp(-.05*Time.dts); // slow damp toward 0 - TODO perhaps only in proportion to turning?
      newestimate = MathHelper.Clamp(newestimate, -.5*Math.PI, .5*Math.PI); // cliffs can only appear so steep!
      EstimateRadians = (float)newestimate;
    }
    float ShipPitchRadians = (float)(.5*Math.PI + Math.Atan2(Vessel.gravity.LocalDir.Y, Vessel.gravity.LocalDir.Z)); //Acos(Vessel.gravity.LocalDir.Y); //
    slopeChart.Text = "Slope: " + Pretty.Radians(EstimateRadians);
    //slopeChart.Text += "\nShip: " + Pretty.Radians(ShipPitchRadians);
    //slopeChart.Text += "\nRel: " + Pretty.Radians(ShipPitchRadians - EstimateRadians);
    slopeChart.Param = 2; slopeChart.TextColor = Graph.StatusColor(1 / (.5*Math.PI) * Math.Abs(EstimateRadians));
    // TODO maybe some kind of graphical thing
    //Log.Output(slopeChart.Text);
    Align();
  }

  static void Align()
  {
    // FIXME move to Slope module
    if (TiltPower == 0) 
      Upright.PitchTiltDegrees = 0;
    else // TILT / terrain gradient
    {
      var linvelg = Vessel.LinearVelocity.Dot(Vessel.gravity.WorldDir); // velocity in gravity direction
      var linvelnog = Vessel.LinearVelocity - Vessel.gravity.WorldDir*linvelg; // reject to find velocity not in gravity direction
      //var adelta = -thrustController.Error; //altitudedelta; // are we out of our window?
      var vdelta = linvelg; // are we going down?
      var gfw =  Vector3.Normalize(Vessel.shipToWorld.  Right.Cross(Vessel.gravity.WorldDir));
      var grt = -Vector3.Normalize(Vessel.shipToWorld.Forward.Cross(Vessel.gravity.WorldDir));
      var fdelta = linvelnog.Dot(gfw); // are we going forward?
      var rdelta = linvelnog.Dot(grt);
      var tdelta = Vessel.LinearAcceleration.Dot(gfw); // are we accelerating forward? in m*s^-2
      var sdelta = Math.Min(1, Math.Abs(fdelta)) * Slope.EstimateRadians; // follow terrain slope as best as we can measure it, if moving
      sdelta *= (float)Math.Exp(-.001f * Planet.Height); // terrain appears flatter from high altitudes; anyway we follow it less
      var speed = Vessel.Controller.GetShipSpeed();
      float tiltfilterrate = .3f / (.001f + .02f*(float)speed); // slow the filtering when moving quickly; fast when stopped so it settles.
      //float apitch = adelta * fdelta * .1f; //  our error relative to setpoint matches terrain gradient - kinda!
      float spitch = sdelta; //0; // terrain slope factor
      //float vpitch = vdelta * fdelta * -.1f; //   moving downward?
      //float tpitch = tdelta * -.0001f*(tdelta &gt; 0 ? .125f : 2f); //tilt due to forward/reverse acceleration 
      //float fpitch = fdelta * .025f; // tilt due to forward velocity
      //Log.Output("spitch: " + Pretty._(spitch));
      //Log.Output("tpitch: " + Pretty._(tpitch));
      float newpitchofs;
      if (Math.Max(Utility.Sqr(rdelta), Utility.Sqr(vdelta)) &gt; Utility.Sqr(fdelta) // when mostly going vertical or sideways
        || Math.Abs(fdelta) &lt; .05f) // not moving significantly forward/back
      {
        newpitchofs = 0; // assume no slope, don't prefer any tilt, let filter slowly bring it back to level
      }
      else
      {
        newpitchofs = (spitch) * TiltPower;
      }
      newpitchofs = (float)MathHelper.Lerp(newpitchofs, Rotion.deg2rad * Upright.PitchTiltDegrees, Math.Exp(-tiltfilterrate * Time.dts));
      Upright.PitchTiltDegrees = MathHelper.ToDegrees(newpitchofs);
    }
  }
  static bool Parse(string[] tokens)
  {
    string varn = tokens[0];
    if (tokens.Length != 2)
      return false;
    else
    {
      double val;
      if (!double.TryParse(tokens[1], out val)) return false;
      if (varn == "tiltpower")
        TiltPower = (float)val;
      else return false;
    }
    return true;
  }

  static string[] Save()
  {
    return new[] { "tiltpower=" + TiltPower };
  }
  static float oldheight; // track terrain gradient delta
}

// HOVER
// Keeps Vessel at certain altitude above terrain.
// Uses Motion module to manage the thrust overrides.
// Depends on Planet module for altitude/height.
public static class Hover
{
  public static Module Init()
  {
    Chart.Title["altlock"] = altLockChart;
    //Chart.Title["descen"] = descentChart; // TODO
    Chart.Title["detail"] = detailChart;
    var m = new Module(); m.Name = "Hover"; m.Tick = Update; m.Parse = Parse; m.Save = Save; return m;
  }

  public static bool AltitudeLocked;
  public static double TargetAltitude; // where was locked (rel sealevel or terrain); possibly negative
  public static MyPlanetElevation TargetMode;

  public static float CorrectPower2 = 2; // controls position delta portion squared
  public static float CorrectPower = 4; // controls position delta portion
  public static float HistoryPower = 0; // controls inertial portion, which may help with strange loads, but might just cause other problems
  public static float DampPower = 20; // controls linear velocity linear portion FIXME names
  public static float DampPower2 = 1; // controls linear velocity quadric portion
  public static float ThrustVelSlop = .5f; // velocity dead zone slop threshold
  public static float ThrustPosSlop = .25f; // position dead zone slop threshold
  public static float SlopePredict = 1f; // anticipate slope in advance

  public static float MaxDownwardVelocity = 25; // in m/s, failsafe prevents dangerous free-fall or worse when dropping off a cliff
 
  public static Chart altLockChart = new Chart(); // lock-relative altitude info
  //public static Chart descentChart = new Chart(); // regarding descent rate mgmt
  public static Chart detailChart = new Chart();

  static void Update()
  {
    if (Vessel.Controller == null || Vessel.gravity.Strength &lt; .01)
    {
      Motion.NoMoveVessel();
      return; //Log.Output("No Gravity!");
    }
    float altitudedelta = 0;
    var linvelg = Vessel.LinearVelocity.Dot(Vessel.gravity.WorldDir); // velocity in gravity direction

    if (!AltitudeLocked)
    {
      altLockChart.Text = "Unlocked";
      Motion.NoMoveVessel(); // be safe
    }
    else
    {
      altLockChart.Text = "Locked at " + Pretty._((float)TargetAltitude) + " m";
      switch (TargetMode)
      { // measure altitudedelta, fix invalid locks
        default:
        case MyPlanetElevation.Sealevel: altitudedelta = (float)(TargetAltitude - Planet.Altitude); altLockChart.Text += " from sealevel\n";
          if (TargetAltitude &lt; -Planet.Radius) ResetLock();
          break;
        case MyPlanetElevation.Surface:  altitudedelta = (float)(TargetAltitude - Planet.Height  ); altLockChart.Text += " from ground\n"  ;
          altitudedelta += (float)(Planet.Height * .5f * Math.Sin(Slope.EstimateRadians)); // height measured downward overestimates on steep slopes
          if (TargetAltitude &lt;= 0) ResetLock();
          break;
      }
      altLockChart.Text += Graph.Limit(altitudedelta, ThrustPosSlop, ThrustPosSlop*2, Graph.smChartWidth); altLockChart.Param = Graph.row2fontsize;
      if (SlopePredict &gt; 0 &amp;&amp; Slope.EstimateRadians &gt; 0)//&amp;&amp; linvelg &lt; 0 
      {
        var fwvelnog = Vessel.WorldToShipDir(Vessel.LinearVelocity - Vessel.gravity.WorldDir * linvelg).Z; // in m/s
        altitudedelta -= fwvelnog * (float)Math.Sin(Slope.EstimateRadians) * Time.dts;
      }
      //Log.Output("altd=" + Pretty._(altitudedelta));
      var overridethrust = new Vector3();
      if (Math.Abs(altitudedelta) &lt; ThrustPosSlop
        &amp;&amp; Math.Abs(linvelg) &lt; ThrustVelSlop)
      { // turn on inertial dampers, stop correcting, we're good!
        thrustController.Integral = 0; // clear it out between corrections
      }
      else
      {
        var tpower = 0f;
        // PID error is all relative to the (possibly moving circumstance surrounding the) setpoint
        thrustController.Kp2 = CorrectPower2; // TODO
        thrustController.Kp = CorrectPower;
        thrustController.Ki = HistoryPower;
        thrustController.Kd = DampPower;
        thrustController.Kd2 = DampPower2;
        tpower = thrustController.Advance(Time.dts, altitudedelta);
        var gravtraveldir = Vessel.gravity.LocalDir * Math.Sign(linvelg); // +/- TODO
#if false // FIXME this thrust cap doesn't account for gravity - in fact it may be the problem I've been looking for.  Why cap in *both* directions?!!
            var stoprate = Motion.ThrustCapInDirection(gravtraveldir) / (float)Vessel.Mass;
        var tmax = PIDControllerFloat.MaxVelocityForDistanceStoprate(Math.Abs(altitudedelta), stoprate);
        tpower = Utility.ClampAbs(tpower, tmax);
#endif
		if (Planet.Height &lt; 5000) // allow uncontrolled free-fall/descent only at high altitude
        {
          float gslow = Math.Max(0f, linvelg - MaxDownwardVelocity);
          if (gslow &gt; 0) {
            tpower = Math.Min(tpower, (gslow * (1 + gslow)) * -.9f * Vessel.Gravity.StandardG); // should stop thrusting downward and slow us if we go too fast
			Log.Output("slowing descent");
		  }
        }
        overridethrust = Vessel.gravity.WorldDir * tpower;
        //if (overridethrust.LengthSquared() &gt; 1e-4f) // if we're correcting anyway,
        { // since we will override the dampeners which would ordinarily stop for us, think they use a PID though maybe.  
          if (altitudedelta &gt; 0) // unless we want to fall
          {
            overridethrust -= Vessel.gravity.World; // we expect g force.  Pre-emptively counter it
            Log.Output("defying gravity");
          }
          var joy = Vessel.Controller.MoveIndicator;
          var move = new Vector3(); // in world space
          if (joy.LengthSquared() &gt; 0) // support user control!
          { // add whatever the user is trying to do to our correction
            var cap = Motion.ThrustCapsInDirection(joy);
            move += Vessel.ShipToWorldDir(cap);
          }
          else {
            overridethrust -= Vessel.gravity.WorldDir * linvelg; // counter velocity in G dir, bring to a stop altitude-wise.  I was trying to rely on the PID for this, but...
            if (Vessel.Controller.DampenersOverride)
            { // replace inertial damping that would be suppressed
              move += Motion.LinearDampeningAcc(.04, .04); // TODO tune to match built-in
            }
          }
          //move = Vector3.Reject(move, Vessel.gravity.LocalDir); // unless it's contrary to our correction (FIXME causes problems)
          overridethrust += move;
          //overridethrust *= (float)Vessel.Mass; // We must move the entire ship! but AccelerateVessel handles it
        }
      }
      //Motion.ThrustVessel(overridethrust, "hover");
      Motion.AccelerateVessel(Vessel.WorldToShipDir(overridethrust), "hover");
    }
    LogReports();
  }

  static void ResetLock()
  {
    AltitudeLocked = false;
    Motion.NoMoveVessel();
  }

  static void Stop()
  {
    Time.Stop();
    ResetLock();
  }

  static void Unlock()
  {
    ResetLock();
    Time.Go();
  }

  static void LockHeight()
  {
    if (!AltitudeLocked || TargetMode != MyPlanetElevation.Surface)
    {
      TargetAltitude = Planet.Height; TargetMode = MyPlanetElevation.Surface; AltitudeLocked = true;
    }
    Time.Go();
  }

  static void LockAltitude()
  {
    if (!AltitudeLocked || TargetMode != MyPlanetElevation.Sealevel)
    {
      TargetAltitude = Planet.Altitude; TargetMode = MyPlanetElevation.Sealevel; AltitudeLocked = true;
    }
    Time.Go();
  }

  static bool Parse(string[] tokens)
  {
    string varn = tokens[0];
    if (tokens.Length == 1)
    {
         if (varn == "stop" || varn == "reset") Stop();
      else if (varn == "lockh") LockHeight();
      else if (varn == "lock") LockAltitude();
      else if (varn == "unlock") Unlock();
      else return false;
    }
    else
    {
      double val;
      if (!double.TryParse(tokens[1], out val)) return false;
      if (varn == "targetaltitude")
        TargetAltitude = val;
      else if (varn == "maxdownwardvelocity" &amp;&amp; val &gt;= 0)
        MaxDownwardVelocity = (float)val;
      else if (varn == "thrustcorrectionpower2" || varn == "alignlinearresponsep2")
        CorrectPower2 = (float)val;
      else if (varn == "thrustcorrectionpower" || varn == "alignlinearresponsep")
        CorrectPower = (float)val;
      else if (varn == "thrusthistorypower" || varn == "alignlinearresponsei")
        HistoryPower = (float)val;
      else if (varn == "thrustdampingpower2" || varn == "alignlinearresponsed2")
        DampPower2 = (float)val;
      else if (varn == "thrustdampingpower" || varn == "alignlinearresponsed")
        DampPower = (float)val;
      else if (varn == "thrustvelslop")
        ThrustVelSlop = (float)val;
      else if (varn == "thrustposslop")
        ThrustPosSlop = (float)val;
      else return false;
    }
    return true;
  }

  static string[] Save()
  {
    var data = new List&lt;string&gt;();
    data.Add("maxdownwardvelocity=" + MaxDownwardVelocity); // failsafe
    data.Add("alignlinearresponsep2=" + CorrectPower2);
    data.Add("alignlinearresponsep=" + CorrectPower);
    data.Add("alignlinearresponsei=" + HistoryPower);
    data.Add("alignlinearresponsed2=" + DampPower2);
    data.Add("alignlinearresponsed=" + DampPower);
    data.Add("thrustvelslop=" + ThrustVelSlop);
    data.Add("thrustposslop=" + ThrustPosSlop);
    if (AltitudeLocked) data.Add(TargetMode == MyPlanetElevation.Surface ? "lockh" : "lock"); // lock type
    else data.Add("unlock");
    data.Add("targetaltitude=" + TargetAltitude); // lock state / height; must write out *after* lock/lockh because those fiddle with it
    return data.ToArray();
  }

  static void LogReports()
  {
    Log.Output(altLockChart.Text);
    detailChart.Text = Log.log.ToString() + Log.scan.ToString();
    var smallChart = altLockChart; //Utility.Square(DateTime.Now.Ticks * .0003f) ? altLockChart : descentChart;
    var cornerChart = smallChart;
    Chart.Subtype["corner"] = cornerChart; // TODO alternate
  }

  static PIDControllerFloat thrustController = new PIDControllerFloat();
}

// LOG

public static class Log
{
  public static Module Init()
  {
    Chart.Title["log"] = logChart; logChart.Param = .8f;
    Chart.Title["scan"] = scanChart; scanChart.Param = .8f;
    Chart.Title["err"] = errChart; errChart.Param = 1f;
    var m = new Module(); m.Name = "Log"; m.Tick = Update; return m;
  }

  public static Action&lt;string&gt; Echo = s =&gt; {}; // patch from ctor, so all modules can easily access it
  
  public static void Output(string s) { log.AppendLine(s); }
  public static void Format(string format, params object[] args) { log.AppendFormat(format, args); }
   
  public static System.Text.StringBuilder log = new System.Text.StringBuilder(); // gets scanLog appended then cleared after each Show
  public static System.Text.StringBuilder scan = new System.Text.StringBuilder(); // avoid rebuilding each Run, cleared each Scan
  public static System.Text.StringBuilder diagnostic = new System.Text.StringBuilder(); // cleared each Scan, written to screen CustomData
  
  public static Chart logChart = new Chart();
  public static Chart scanChart = new Chart();
  public static Chart errChart = new Chart();

  static void Update()
  {
    log.Append(scan);
    logChart.Text = log.ToString();
    log.Clear();
    scanChart.Text = scan.ToString(); // could just update during Scan, but would miss later Modules
    errChart.Text = diagnostic.ToString();
  }
}

// CHART
// can show on a text panel visually
public class Chart
{
  static Chart()
  {
    Title["logo"] = Logo;
    //Subtype["Wide"] = Logo;
    Subtype["Corner"] = Logo;
  }

  public static Module Init()
  {
    var m = new Module();
    m.Name = "Chart";
    m.Tick = Update;
    return m;
  }
  public string Text = null; // text or texture name (will show "OFFLINE" if null either way)
  public float Param = 0f; // override font size or image time if &gt; 0
  public bool Texture = false; // if true, Text is texture name to show 
  public bool Compact = true; // if true, font size is doubled on wide panels, halved on large ship corner panels

  public Color TextColor = Color.White;
  public Color BackColor = Color.Black;

  public void UpdateColor(double err)
  {
    TextColor = err &lt;= 0 ? Graph.Twirl : Graph.StatusColor(err);
  }

  public void MakeFill(string quant, double fill)
  {
    Text = quant + ": " + fill.ToString("P1") //(int)Math.Round(fill * 100) + " %" // (fill * 100).ToString("F0") + "%"; //
        + '\n' + Graph.Fraction(fill, Graph.smChartWidth);
    Param = Graph.row2fontsize;
    TextColor = Graph.StatusColor(1f - fill);
  }

  static void Update()
  {
    if (Standard.Text == null) Standard.Text = Log.scan.ToString(); // + Log.diagnostic;
    Logo.TextColor = new Color(Utility.Wave(1f / 24000 * Time.ams));
    Logo.BackColor = Graph.Glo(Graph.Hue(1f / 12000 * Time.ams), .8f*(float)Math.Pow(Utility.Pulse(Utility.Wave(1f / 7000 * Time.ams)), 16));
    Logo.Param = Utility.Tri(1f / 70000 * Time.ams) * .4f + 1.9f; // slow pingpong fontsize between 1.9 and 2.3
  }

  public void Show(IMyTextPanel display)
  {
    var s = display as IMyTextSurface;
    if (Text == null || Texture)
    { s.ContentType = VRage.Game.GUI.TextPanel.ContentType.TEXT_AND_IMAGE; }
    if (Text != null)
      if (Texture)
      {
        foreach (var image in Text.Split('|'))
          s.AddImageToSelection(image, true);
      }
      else
      {
        s.BackgroundColor = BackColor;
        s.FontColor = TextColor;
        if (Compact &amp;&amp; Screen.IsWide(display)) Param *= 2;
        else if (Screen.IsCorner(display) &amp;&amp; (!Compact || display.CubeGrid.GridSize &gt; 1f)) Param *= .5f;
        if (Param &gt; 0) s.FontSize = Param;
        s.ClearImagesFromSelection();
        s.WriteText(Text);
        s.ContentType = VRage.Game.GUI.TextPanel.ContentType.TEXT_AND_IMAGE;
        //s.CustomData = Log.diagnostic.ToString(); // using CustomData as private (diagnostic) output for LCDs
      }
  }

  public void Show(IMyLightingBlock light)
  {
    var c = BackColor != Color.Black ? BackColor : TextColor;
    Screen.SetLightColor(light, c);
    // CustomData is selector for lights (input) so do not write to it
  }
 
  public static Chart Logo = new Chart();
  public static Chart Standard = new Chart(); // default
    
  public static Dictionary&lt;string, Chart&gt; Title   = new Dictionary&lt;string, Chart&gt;(); // map each Public Title for screens (CustomData for other blocks) substring to its graph; only put lowercase strings as keys!
  public static Dictionary&lt;string, Chart&gt; Subtype = new Dictionary&lt;string, Chart&gt;(); // map each Subtype to its graph (case sensitive)

  static string GetSubtype(IMyTerminalBlock block) { return block.BlockDefinition.SubtypeId; } // case sensitive
  static string GetName(IMyTerminalBlock block) { return block.CustomName.ToLowerInvariant(); } // case insensitive
  static string GetCustomData(IMyTerminalBlock block) { return block.CustomData.ToLowerInvariant(); } // case insensitive
  static string GetTitle(IMyTextPanel screen) { return screen.GetPublicTitle().ToLowerInvariant(); } // case insensitive
  static Chart Select(IMyTextPanel screen, Dictionary&lt;string, Chart&gt; dict, Func&lt;IMyTextPanel, string&gt; info)
  {
    foreach (var p in dict) if (info(screen).Contains(p.Key)) return p.Value;
    return null;
  }
  static Chart Select(IMyLightingBlock light, Dictionary&lt;string, Chart&gt; dict, Func&lt;IMyLightingBlock, string&gt; info)
  {
    foreach (var p in dict) if (info(light).Contains(p.Key)) return p.Value;
    return null;
  }
    
  public static Chart ForScreen(IMyTextPanel screen)
  { // select by title or LCD type
    Chart chart = null;
    chart = chart ?? Select(screen, Title,   GetTitle);
    chart = chart ?? Select(screen, Subtype, GetSubtype);
    chart = chart ?? Standard;
    return chart;
  }
  public static Chart ForLight(IMyLightingBlock light)
  { // select by CustomData or subtype    
    Chart chart = null;
    chart = chart ?? Select(light, Title,  GetCustomData);
    chart = chart ?? Select(light, Subtype, GetSubtype); 
    return chart;
  }
  public static void ShowFor(IMyTextPanel screen)
  {
    Chart chart;
    chart = ForScreen(screen);
    if (chart != null) chart.Show(screen);
  }
  public static void ShowFor(IMyLightingBlock light)
  {
    var chart = ForLight(light);
    if (chart != null) chart.Show(light);
  }
}

// SCREEN

public static class Screen
{
  public static Module Init()
  {
    var m = new Module(); m.Name = "Screen"; m.Scan = Rescan; m.Tick = Update; m.Parse = Parse; return m;
  }

  static void Update()
  {
    foreach (var s in Screens) Chart.ShowFor(s);
    foreach (var l in  Lights) Chart.ShowFor(l);
  }

  static bool Rescan()
  {
    Screens.Clear(); Lights.Clear();
    if (Scanner.Group == null) return true; // lack of group means don't find lcds and lights, which it might manipulate accidentally to great dismay
    Scanner.GetBlocksOfType(Screens);
    Scanner.GetBlocksOfType(Lights);
    if (Screens.Count == 0) Log.scan.AppendLine("No displays in group!  Minimal diagnostics."); // not fatal
    return true;
  }
    
  static bool Parse(string[] tokens)
  {
    string varn = tokens[0];
    if (tokens.Length == 1)
    {
      if (varn == "stop" || varn == "reset") Off(); // overload to turn "off" displays/lights
      else return false;
    }
    else
    {
      double dvalue;
      if (!double.TryParse(tokens[1], out dvalue)) return false;
    }
    return true;
  }

  public static int PipColumns(double pipsw, int charPips)
  {
    return (int)Math.Floor(pipsw / charPips);
  }
  public static int PipRows(double pipsh)
  { 
    return (int)Math.Floor(pipsh / 33);
  }
  public static int FontColumns(double fontSize, int charPips)
  { // how many columns of char can fit on a standard screen at given fontSize?
    return PipColumns(584 / fontSize, charPips);
  }
  // aids scaling Charts shown on the wrong kind of panel
  public static bool IsWide(IMyTextPanel screen)
  {
    return screen.BlockDefinition.SubtypeId.Contains("Wide");
  }
  public static bool IsCorner(IMyTextPanel screen)
  {
    return screen.BlockDefinition.SubtypeId.Contains("Corner");
  }

  // turns all LCDs off to show "OFFLINE" or texture.
  public static void Off()
  {
    foreach (var s in Screens)
    { // clear screens on save, so that on Load we know anything written was from the loading script
      var surf = s as IMyTextSurface;
      if (surf == null) continue;
      surf.WriteText("");
      surf.BackgroundColor = Color.Black;
      surf.AddImageToSelection("Offline", true);
      s.ContentType = VRage.Game.GUI.TextPanel.ContentType.TEXT_AND_IMAGE;
    }
    foreach (var l in Lights)
    {
      SetLightColor(l, Color.Black);
    }
  }

  public static void SetLightColor(IMyLightingBlock l, Color c)
  {
    l.Color = c;
  }

  static List&lt;IMyTextPanel&gt; Screens = new List&lt;IMyTextPanel&gt;();
  static List&lt;IMyLightingBlock&gt; Lights = new List&lt;IMyLightingBlock&gt;();
}

// HOVERALIGNER

static class HoverAligner
{
  public static Module Init()
  {
    var m = new Module(); m.Name = "HoverAligner"; return m;
  }
  public static void DisplayUsage()
  {
    Log.Echo(ScriptTitle + @"");
  }
  public static void StopOverrides()
  {
    Rotion.NoTurnVessel();
    Motion.NoMoveVessel();
  }
}

public void Save()
{
  Module.Store();
}

public Program()
{
  Log.Echo = Echo;
  Chart.Logo.Text = ScriptTitle;
  Chart.Standard = Hover.detailChart;
  // setup program execution structure by modules
  Module.run = Runtime;
  Module.Init(new Module[] {
    Scanner.Init(Me, GridTerminalSystem, GroupName),
    Time.Init(),
    Graph.Init(),
    Vessel.Init(),
    Planet.Init(),
    Rotion.Init(),
    Motion.Init(),
    Upright.Init(),
    Slope.Init(),
    Hover.Init(),
    HoverAligner.Init(),
    Log.Init(),
    Chart.Init(),
    Screen.Init(),
    });
  Storage = ""; // unused, using Me.CustomData to persist
  Runtime.UpdateFrequency = Sandbox.ModAPI.Ingame.UpdateFrequency.Once; // give us a chance to load and initialize later once the block scan is available
}

public void Main(string arg, UpdateType updateSource)
{
  Module.run = Runtime;
  try {
    if (!Module.Commands(arg, true)) HoverAligner.DisplayUsage();
    Module.Update();
  } catch (Exception e) {
    HoverAligner.StopOverrides();
    throw new Exception("Main:\n" + e.Message);
  }
}

</Program>
              <Storage />
              <DefaultRunArgument>stop</DefaultRunArgument>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Cockpit">
              <SubtypeName>OpenCockpitSmall</SubtypeName>
              <EntityId>126278186824426307</EntityId>
              <Min x="-1" y="3" z="4" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <Owner>144115188075855883</Owner>
              <BuiltBy>144115188075855883</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyInventoryBase</TypeId>
                    <Component xsi:type="MyObjectBuilder_Inventory">
                      <Items />
                      <nextItemId>0</nextItemId>
                      <Volume>1</Volume>
                      <Mass>9223372036854.775807</Mass>
                      <MaxItemCount>2147483647</MaxItemCount>
                      <Size xsi:nil="true" />
                      <InventoryFlags>CanReceive CanSend</InventoryFlags>
                      <RemoveEntityOnEmpty>false</RemoveEntityOnEmpty>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>1</NumberInGrid>
              <UseSingleWeaponMode>false</UseSingleWeaponMode>
              <Toolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots />
                <SlotsGamepad />
              </Toolbar>
              <SelectedGunId xsi:nil="true" />
              <BuildToolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots />
                <SlotsGamepad />
              </BuildToolbar>
              <OnLockedToolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots />
                <SlotsGamepad />
              </OnLockedToolbar>
              <PilotRelativeWorld>
                <Position x="-2.5683159828186035" y="-2.1250574588775635" z="0.48572355508804321" />
                <Forward x="0.9814238" y="0.06542313" z="-0.180352926" />
                <Up x="-0.0599210374" y="0.9975612" z="0.0357948467" />
                <Orientation>
                  <X>0.0329424627</X>
                  <Y>-0.6393265</Y>
                  <Z>0.0115857469</Z>
                  <W>0.768142045</W>
                </Orientation>
              </PilotRelativeWorld>
              <PilotGunDefinition xsi:nil="true" />
              <IsInFirstPersonView>false</IsInFirstPersonView>
              <OxygenLevel>0</OxygenLevel>
              <PilotJetpackEnabled xsi:nil="true" />
              <TextPanels>
                <MySerializedTextPanelData>
                  <ChangeInterval>0</ChangeInterval>
                  <Font Type="MyObjectBuilder_FontDefinition" Subtype="Debug" />
                  <FontSize>1</FontSize>
                  <ShowText>NONE</ShowText>
                  <FontColor>
                    <PackedValue>4294967295</PackedValue>
                    <X>255</X>
                    <Y>255</Y>
                    <Z>255</Z>
                    <R>255</R>
                    <G>255</G>
                    <B>255</B>
                    <A>255</A>
                  </FontColor>
                  <BackgroundColor>
                    <PackedValue>4278190080</PackedValue>
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R>0</R>
                    <G>0</G>
                    <B>0</B>
                    <A>255</A>
                  </BackgroundColor>
                  <CurrentShownTexture>0</CurrentShownTexture>
                  <ContentType>SCRIPT</ContentType>
                  <SelectedScript>TSS_ArtificialHorizon</SelectedScript>
                  <TextPadding>2</TextPadding>
                  <CustomizeScripts>true</CustomizeScripts>
                  <ScriptBackgroundColor>
                    <PackedValue>4288108544</PackedValue>
                    <X>0</X>
                    <Y>88</Y>
                    <Z>151</Z>
                    <R>0</R>
                    <G>88</G>
                    <B>151</B>
                    <A>255</A>
                  </ScriptBackgroundColor>
                  <ScriptForegroundColor>
                    <PackedValue>4294962611</PackedValue>
                    <X>179</X>
                    <Y>237</Y>
                    <Z>255</Z>
                    <R>179</R>
                    <G>237</G>
                    <B>255</B>
                    <A>255</A>
                  </ScriptForegroundColor>
                  <Sprites>
                    <Length>0</Length>
                  </Sprites>
                </MySerializedTextPanelData>
              </TextPanels>
              <TargetData>
                <TargetId>0</TargetId>
                <IsTargetLocked>false</IsTargetLocked>
                <LockingProgress>0</LockingProgress>
              </TargetData>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_BatteryBlock">
              <SubtypeName>SmallBlockBatteryBlock</SubtypeName>
              <EntityId>136116489464933190</EntityId>
              <Min x="-3" y="3" z="0" />
              <BlockOrientation Forward="Up" Up="Left" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <Owner>144115188075855883</Owner>
              <BuiltBy>144115188075855883</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>3</NumberInGrid>
              <Enabled>true</Enabled>
              <CurrentStoredPower>1</CurrentStoredPower>
              <ProducerEnabled>true</ProducerEnabled>
              <MaxStoredPower>0</MaxStoredPower>
              <SemiautoEnabled>false</SemiautoEnabled>
              <OnlyDischargeEnabled>false</OnlyDischargeEnabled>
              <ChargeMode>0</ChargeMode>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_BatteryBlock">
              <SubtypeName>SmallBlockBatteryBlock</SubtypeName>
              <EntityId>89820332539046914</EntityId>
              <Min x="-3" y="3" z="-3" />
              <BlockOrientation Forward="Up" Up="Right" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <Owner>144115188075855883</Owner>
              <BuiltBy>144115188075855883</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>4</NumberInGrid>
              <Enabled>true</Enabled>
              <CurrentStoredPower>1</CurrentStoredPower>
              <ProducerEnabled>true</ProducerEnabled>
              <MaxStoredPower>0</MaxStoredPower>
              <SemiautoEnabled>false</SemiautoEnabled>
              <OnlyDischargeEnabled>false</OnlyDischargeEnabled>
              <ChargeMode>0</ChargeMode>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_BatteryBlock">
              <SubtypeName>SmallBlockBatteryBlock</SubtypeName>
              <EntityId>134634031739986530</EntityId>
              <Min x="2" y="3" z="-3" />
              <BlockOrientation Forward="Up" Up="Left" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <Owner>144115188075855883</Owner>
              <BuiltBy>144115188075855883</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>5</NumberInGrid>
              <Enabled>true</Enabled>
              <CurrentStoredPower>1</CurrentStoredPower>
              <ProducerEnabled>true</ProducerEnabled>
              <MaxStoredPower>0</MaxStoredPower>
              <SemiautoEnabled>false</SemiautoEnabled>
              <OnlyDischargeEnabled>false</OnlyDischargeEnabled>
              <ChargeMode>0</ChargeMode>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_BatteryBlock">
              <SubtypeName>SmallBlockBatteryBlock</SubtypeName>
              <EntityId>73162905598637613</EntityId>
              <Min x="-1" y="3" z="-3" />
              <BlockOrientation Forward="Up" Up="Backward" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <Owner>144115188075855883</Owner>
              <BuiltBy>144115188075855883</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>6</NumberInGrid>
              <Enabled>true</Enabled>
              <CurrentStoredPower>1</CurrentStoredPower>
              <ProducerEnabled>true</ProducerEnabled>
              <MaxStoredPower>0</MaxStoredPower>
              <SemiautoEnabled>false</SemiautoEnabled>
              <OnlyDischargeEnabled>false</OnlyDischargeEnabled>
              <ChargeMode>0</ChargeMode>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>99269964959287248</EntityId>
              <Min x="1" y="2" z="6" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>19</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>SmallBlockSmallAtmosphericThrust</SubtypeName>
              <EntityId>90698600282026438</EntityId>
              <Min x="-3" y="2" z="6" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0" y="-0.8" z="0.49" />
              <SkinSubtypeId>Clean_Armor</SkinSubtypeId>
              <BuiltBy>144115188075855883</BuiltBy>
              <ComponentContainer>
                <Components>
                  <ComponentData>
                    <TypeId>MyTimerComponent</TypeId>
                    <Component xsi:type="MyObjectBuilder_TimerComponent">
                      <Repeat>true</Repeat>
                      <TimeToEvent>0</TimeToEvent>
                      <SetTimeMinutes>0</SetTimeMinutes>
                      <TimerEnabled>true</TimerEnabled>
                      <RemoveEntityOnTimer>false</RemoveEntityOnTimer>
                      <TimerType>Frame100</TimerType>
                      <FramesFromLastTrigger>0</FramesFromLastTrigger>
                      <TimerTickInFrames>100</TimerTickInFrames>
                      <IsSessionUpdateEnabled>false</IsSessionUpdateEnabled>
                    </Component>
                  </ComponentData>
                </Components>
              </ComponentContainer>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <NumberInGrid>20</NumberInGrid>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
          </CubeBlocks>
          <XMirroxPlane x="0" y="2" z="-3" />
          <BlockGroups>
            <MyObjectBuilder_BlockGroup>
              <Name>Downthrust</Name>
              <Blocks>
                <Vector3I>
                  <X>-4</X>
                  <Y>2</Y>
                  <Z>1</Z>
                </Vector3I>
                <Vector3I>
                  <X>4</X>
                  <Y>2</Y>
                  <Z>0</Z>
                </Vector3I>
                <Vector3I>
                  <X>-4</X>
                  <Y>2</Y>
                  <Z>0</Z>
                </Vector3I>
                <Vector3I>
                  <X>4</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3I>
                <Vector3I>
                  <X>-4</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3I>
                <Vector3I>
                  <X>4</X>
                  <Y>2</Y>
                  <Z>1</Z>
                </Vector3I>
              </Blocks>
            </MyObjectBuilder_BlockGroup>
            <MyObjectBuilder_BlockGroup>
              <Name>Aligner</Name>
              <Blocks>
                <Vector3I>
                  <X>-4</X>
                  <Y>2</Y>
                  <Z>1</Z>
                </Vector3I>
                <Vector3I>
                  <X>4</X>
                  <Y>2</Y>
                  <Z>0</Z>
                </Vector3I>
                <Vector3I>
                  <X>-4</X>
                  <Y>2</Y>
                  <Z>0</Z>
                </Vector3I>
                <Vector3I>
                  <X>4</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3I>
                <Vector3I>
                  <X>-4</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3I>
                <Vector3I>
                  <X>4</X>
                  <Y>2</Y>
                  <Z>1</Z>
                </Vector3I>
                <Vector3I>
                  <X>0</X>
                  <Y>4</Y>
                  <Z>3</Z>
                </Vector3I>
                <Vector3I>
                  <X>0</X>
                  <Y>5</Y>
                  <Z>2</Z>
                </Vector3I>
                <Vector3I>
                  <X>0</X>
                  <Y>3</Y>
                  <Z>-1</Z>
                </Vector3I>
              </Blocks>
            </MyObjectBuilder_BlockGroup>
          </BlockGroups>
          <DisplayName>Hoverscript Testbed</DisplayName>
          <DestructibleBlocks>true</DestructibleBlocks>
          <IsRespawnGrid>false</IsRespawnGrid>
          <LocalCoordSys>0</LocalCoordSys>
          <TargetingTargets />
          <GridPresenceTier>Tier1</GridPresenceTier>
        </CubeGrid>
      </CubeGrids>
      <EnvironmentType>None</EnvironmentType>
      <WorkshopId>0</WorkshopId>
      <OwnerSteamId>76561197979296883</OwnerSteamId>
      <Points>0</Points>
    </ShipBlueprint>
  </ShipBlueprints>
</Definitions>